var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = QuantumToolbox","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#API:-Quantum-object-functions","page":"API","title":"Quantum object functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"BraQuantumObject\nKetQuantumObject\nOperatorQuantumObject\nSuperOperatorQuantumObject\nQuantumObject\nQobj\nket2dm\nisbra\nisket\nisoper\nissuper\nsize\nlength\nLinearAlgebra.tr\nLinearAlgebra.norm\nLinearAlgebra.kron\ntensor\n⊗","category":"page"},{"location":"api/#QuantumToolbox.BraQuantumObject","page":"API","title":"QuantumToolbox.BraQuantumObject","text":"BraQuantumObject <: QuantumObjectType\n\nAbstract type representing a bra state brapsi.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.KetQuantumObject","page":"API","title":"QuantumToolbox.KetQuantumObject","text":"KetQuantumObject <: QuantumObjectType\n\nAbstract type representing a ket state ketpsi.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.OperatorQuantumObject","page":"API","title":"QuantumToolbox.OperatorQuantumObject","text":"OperatorQuantumObject <: QuantumObjectType\n\nAbstract type representing an operator hatO.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.SuperOperatorQuantumObject","page":"API","title":"QuantumToolbox.SuperOperatorQuantumObject","text":"SuperOperatorQuantumObject <: QuantumObjectType\n\nAbstract type representing a super-operator hatmathcalO.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.QuantumObject","page":"API","title":"QuantumToolbox.QuantumObject","text":"mutable struct QuantumObject{MT<:AbstractArray,ObjType<:QuantumObjectType}\n    data::MT\n    type::Type{ObjType}\n    dims::Vector{Int}\nend\n\nJulia struct representing any quantum operator.\n\nExamples\n\njulia> a = destroy(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢\n\njulia> a isa QuantumObject\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.Qobj","page":"API","title":"QuantumToolbox.Qobj","text":"Qobj(A::AbstractArray; type::QuantumObjectType, dims::Vector{Int})\n\nGenerate QuantumObject\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.ket2dm","page":"API","title":"QuantumToolbox.ket2dm","text":"ket2dm(ψ::QuantumObject)\n\nTransform the ket state ketpsi into a pure density matrix hatrho = dyadpsi.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.isbra","page":"API","title":"QuantumToolbox.isbra","text":"isbra(A::QuantumObject)\n\nChecks if the QuantumObject A is a BraQuantumObject state.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.isket","page":"API","title":"QuantumToolbox.isket","text":"isket(A::QuantumObject)\n\nChecks if the QuantumObject A is a KetQuantumObject state.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.isoper","page":"API","title":"QuantumToolbox.isoper","text":"isoper(A::QuantumObject)\n\nChecks if the QuantumObject A is a OperatorQuantumObject state.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.issuper","page":"API","title":"QuantumToolbox.issuper","text":"issuper(A::QuantumObject)\n\nChecks if the QuantumObject A is a SuperOperatorQuantumObject state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.size","page":"API","title":"Base.size","text":"size(A::QuantumObject)\n\nReturns the size of the matrix or vector corresponding to the QuantumObject A.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.length","page":"API","title":"Base.length","text":"length(A::QuantumObject)\n\nReturns the length of the matrix or vector corresponding to the QuantumObject A.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.tr","page":"API","title":"LinearAlgebra.tr","text":"tr(A::QuantumObject})\n\nReturns the trace of A.\n\nExamples\n\njulia> a = destroy(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢\n\njulia> tr(a' * a)\n190.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.norm","page":"API","title":"LinearAlgebra.norm","text":"norm(A::QuantumObject)\n\nReturns the norm of A.\n\nExamples\n\njulia> ψ = fock(10, 2)\nQuantum Object:   type=Ket   dims=[10]   size=(10,)\n10-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\njulia> norm(ψ)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.kron","page":"API","title":"Base.kron","text":"kron(A::QuantumObject, B::QuantumObject)\n\nReturns the Kronecker product hatA otimes hatB.\n\nExamples\n\njulia> a = destroy(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢\n\njulia> kron(a, a)\nQuantum Object:   type=Operator   dims=[20, 20]   size=(400, 400)   ishermitian=false\n400×400 SparseMatrixCSC{ComplexF64, Int64} with 361 stored entries:\n⠀⠀⠘⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠦\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.tensor","page":"API","title":"QuantumToolbox.tensor","text":"tensor(A1::QuantumObject, A2::QuantumObject, ...)\n\nReturns the Kronecker product hatA_1 otimes hatA_2 otimes cdots.\n\nExamples\n\njulia> x = sigmax()\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true\n2×2 SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅\n\njulia> x_list = fill(x, 3);\n\njulia> tensor(x_list...)\nQuantum Object:   type=Operator   dims=[2, 2, 2]   size=(8, 8)   ishermitian=true\n8×8 SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n     ⋅          ⋅          ⋅      …      ⋅          ⋅      1.0+0.0im\n     ⋅          ⋅          ⋅             ⋅      1.0+0.0im      ⋅    \n     ⋅          ⋅          ⋅         1.0+0.0im      ⋅          ⋅    \n     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅    \n     ⋅          ⋅      1.0+0.0im  …      ⋅          ⋅          ⋅    \n     ⋅      1.0+0.0im      ⋅             ⋅          ⋅          ⋅    \n 1.0+0.0im      ⋅          ⋅             ⋅          ⋅          ⋅\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.:⊗","page":"API","title":"QuantumToolbox.:⊗","text":"⊗(A::QuantumObject, B::QuantumObject)\n\nReturns the Kronecker product hatA otimes hatB.\n\nExamples\n\njulia> a = destroy(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢\n\njulia> a ⊗ a\nQuantum Object:   type=Operator   dims=[20, 20]   size=(400, 400)   ishermitian=false\n400×400 SparseMatrixCSC{ComplexF64, Int64} with 361 stored entries:\n⠀⠀⠘⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠦\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-General-functions","page":"API","title":"General functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"row_major_reshape\nmeshgrid\nsparse_to_dense\ndense_to_sparse\ntidyup\ntidyup!\ngaussian\nptrace\nentropy_vn\nentanglement\nexpect\nwigner\nget_coherence\nn_th\nget_data\nmat2vec\nvec2mat","category":"page"},{"location":"api/#QuantumToolbox.row_major_reshape","page":"API","title":"QuantumToolbox.row_major_reshape","text":"row_major_reshape(Q::AbstractArray, shapes...)\n\nReshapes Q in the row-major order, as numpy. \n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.meshgrid","page":"API","title":"QuantumToolbox.meshgrid","text":"meshgrid(x::AbstractVector, y::AbstractVector)\n\nEquivalent to numpy meshgrid.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sparse_to_dense","page":"API","title":"QuantumToolbox.sparse_to_dense","text":"sparse_to_dense(A::QuantumObject)\n\nConverts a sparse QuantumObject to a dense QuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.dense_to_sparse","page":"API","title":"QuantumToolbox.dense_to_sparse","text":"dense_to_sparse(A::QuantumObject)\n\nConverts a dense QuantumObject to a sparse QuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.tidyup","page":"API","title":"QuantumToolbox.tidyup","text":"tidyup(A::QuantumObject, tol::Real=1e-14)\n\nRemoves those elements of a QuantumObject A whose absolute value is less than tol.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.tidyup!","page":"API","title":"QuantumToolbox.tidyup!","text":"tidyup!(A::QuantumObject, tol::Real=1e-14)\n\nRemoves those elements of a QuantumObject A whose absolute value is less than tol. In-place version of tidyup.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.gaussian","page":"API","title":"QuantumToolbox.gaussian","text":"gaussian(x::Number, μ::Number, σ::Number)\n\nReturns the gaussian function exp left- frac(x - mu)^22 sigma^2 right, where mu and sigma^2 are the mean and the variance respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.ptrace","page":"API","title":"QuantumToolbox.ptrace","text":"ptrace(QO::QuantumObject, sel::Vector{Int})\n\nPartial trace of a quantum state QO leaving only the dimensions with the indices present in the sel vector.\n\nExamples\n\nTwo qubits in the state ketpsi = keteg:\n\njulia> ψ = kron(fock(2,0), fock(2,1))\nQuantum Object:   type=Ket   dims=[2, 2]   size=(4,)\n4-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\njulia> ptrace(ψ, [2])\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im\n\nor in an entangled state ketpsi = frac1sqrt2 left( ketee + ketgg right):\n\njulia> ψ = 1 / √2 * (kron(fock(2,0), fock(2,0)) + kron(fock(2,1), fock(2,1)))\nQuantum Object:   type=Ket   dims=[2, 2]   size=(4,)\n4-element Vector{ComplexF64}:\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n\njulia> ptrace(ψ, [1])\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true\n2×2 Matrix{ComplexF64}:\n 0.5+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.entropy_vn","page":"API","title":"QuantumToolbox.entropy_vn","text":"entropy_vn(ρ::QuantumObject; base::Int=0, tol::Real=1e-15)\n\nCalculates the Von Neumann entropy S = - Tr left hatrho log left( hatrho right) right where hatrho is the density matrix of the system.\n\nThe base parameter specifies the base of the logarithm to use, and when using the default value 0, the natural logarithm is used. The tol parameter describes the absolute tolerance for detecting the zero-valued eigenvalues of the density matrix hatrho.\n\nExamples\n\nPure state:\n\njulia> ψ = fock(2,0)\nQuantum Object:   type=Ket   dims=[2]   size=(2,)\n2-element Vector{ComplexF64}:\n 1.0 + 0.0im\n 0.0 + 0.0im\n\njulia> ρ = ket2dm(ψ)\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im\n\njulia> entropy_vn(ρ, base=2)\n-0.0\n\nMixed state:\n\njulia> ρ = 1 / 2 * ( ket2dm(fock(2,0)) + ket2dm(fock(2,1)) )\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true\n2×2 Matrix{ComplexF64}:\n 0.5+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.0im\n\njulia> entropy_vn(ρ, base=2)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.entanglement","page":"API","title":"QuantumToolbox.entanglement","text":"entanglement(QO::QuantumObject, sel::Vector)\n\nCalculates the entanglement by doing the partial trace of QO, selecting only the dimensions with the indices contained in the sel vector, and then using the Von Neumann entropy entropy_vn. \n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.expect","page":"API","title":"QuantumToolbox.expect","text":"expect(O::QuantumObject, ψ::QuantumObject)\n\nExpectation value of the operator O with the state ψ. The latter can be a KetQuantumObject, BraQuantumObject or a OperatorQuantumObject. If ψ is a density matrix, the function calculates Tr left hatO hatpsi right, while if ψ is a state, the function calculates melpsihatOpsi.\n\nThe function returns a real number if the operator is hermitian, and returns a complex number otherwise.\n\nExamples\n\njulia> ψ = 1 / √2 * (fock(10,2) + fock(10,4));\n\njulia> a = destroy(10);\n\njulia> expect(a' * a, ψ) ≈ 3\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.wigner","page":"API","title":"QuantumToolbox.wigner","text":"wigner(state::QuantumObject, xvec::AbstractVector, yvec::AbstractVector; g::Real=√2,\n    solver::WignerSolver=WignerLaguerre())\n\nGenerates the Wigner quasipropability distribution of state at points xvec + 1im * yvec. The g parameter is a scaling factor related to the value of hbar in the commutation relation x y = i hbar via hbar=2g^2 giving the default value hbar=1.\n\nThe solver parameter can be either WignerLaguerre() or WignerClenshaw(). The former uses the Laguerre polynomial expansion of the Wigner function, while the latter uses the Clenshaw algorithm. The Laguerre expansion is faster for sparse matrices, while the Clenshaw algorithm is faster for dense matrices. The WignerLaguerre solver has an optional parallel parameter which defaults to true and uses multithreading to speed up the calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.get_coherence","page":"API","title":"QuantumToolbox.get_coherence","text":"get_coherence(ψ::QuantumObject)\n\nGet the coherence value alpha by measuring the expectation value of the destruction operator hata on the state ketpsi.\n\nIt returns both alpha and the state  ketdelta_psi = exp ( baralpha hata - alpha hata^dagger ). The latter corresponds to the quantum fulctuations around the coherent state ketalpha.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.n_th","page":"API","title":"QuantumToolbox.n_th","text":"n_th(ω::Number, T::Real)\n\nGives the mean number of excitations in a mode with frequency ω at temperature T: n_rm th (omega T) = frac1e^omegaT - 1\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.get_data","page":"API","title":"QuantumToolbox.get_data","text":"get_data(A::QuantumObject)\n\nReturns the data of a QuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mat2vec","page":"API","title":"QuantumToolbox.mat2vec","text":"mat2vec(A::AbstractMatrix)\n\nConverts a matrix to a vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.vec2mat","page":"API","title":"QuantumToolbox.vec2mat","text":"vec2mat(A::AbstractVector)\n\nConverts a vector to a matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Quantum-states,-operators-and-super-operators","page":"API","title":"Quantum states, operators and super-operators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"spre\nspost\nsprepost\nlindblad_dissipator\ndestroy\ncreate\nsigmap\nsigmam\nsigmax\nsigmay\nsigmaz\neye\nqeye\nfock\nbasis\ncoherent\nrand_dm\nprojection\nsinm\ncosm","category":"page"},{"location":"api/#QuantumToolbox.spre","page":"API","title":"QuantumToolbox.spre","text":"spre(O::QuantumObject, Id_cache=I(size(O,1)))\n\nReturns the super-operator form of O acting on the left of the density matrix operator, mathcalO left(hatOright) left hatrho right = hatO hatrho.\n\nSince the density matrix is vectorized, this super-operator is always a matrix, obtained from mathcalO left(hatOright) boldsymbolcdot = hatmathbb1 otimes hatO.\n\nThe optional argument Id_cache can be used to pass a precomputed identity matrix. This can be useful when the same function is applied multiple times with a known Hilbert space dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spost","page":"API","title":"QuantumToolbox.spost","text":"spost(O::QuantumObject)\n\nReturns the super-operator form of O acting on the right of the density matrix operator, mathcalO left(hatOright) left hatrho right = hatrho hatO.\n\nSince the density matrix is vectorized, this super-operator is always a matrix, obtained from mathcalO left(hatOright) boldsymbolcdot = hatO^T otimes hatmathbb1.\n\nThe optional argument Id_cache can be used to pass a precomputed identity matrix. This can be useful when the same function is applied multiple times with a known Hilbert space dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sprepost","page":"API","title":"QuantumToolbox.sprepost","text":"sprepost(A::QuantumObject, B::QuantumObject)\n\nReturns the super-operator form of A and B acting on the left and the right of the density matrix operator respectively, mathcalO left( hatA hatB right) left hatrho right = hatA hatrho hatB.\n\nSince the density matrix is vectorized, this super-operator is always a matrix, obtained from mathcalO left(hatA hatBright) boldsymbolcdot = textspre(A) * textspost(B).\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.lindblad_dissipator","page":"API","title":"QuantumToolbox.lindblad_dissipator","text":"lindblad_dissipator(O::QuantumObject, Id_cache=I(size(O,1))\n\nReturns the Lindblad super-operator defined as mathcalD left( hatO right) left hatrho right = frac12 left( 2 hatO hatrho hatO^dagger -  hatO^dagger hatO hatrho - hatrho hatO^dagger hatO right) considering the density matrix hatrho in the vectorized form.\n\nThe optional argument Id_cache can be used to pass a precomputed identity matrix. This can be useful when the same function is applied multiple times with a known Hilbert space dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.destroy","page":"API","title":"QuantumToolbox.destroy","text":"destroy(N::Int)\n\nBosonic annihilation operator with Hilbert space cutoff N. This operator acts on a fock state as hata ketn = sqrtn ketn-1.\n\nExamples\n\njulia> a = destroy(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢\n\njulia> fock(20, 3)' * a * fock(20, 4)\n2.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.create","page":"API","title":"QuantumToolbox.create","text":"create(N::Int)\n\nBosonic creation operator with Hilbert space cutoff N. This operator acts on a fock state as hata^dagger ketn = sqrtn+1 ketn+1.\n\nExamples\n\njulia> a_d = create(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠢⡀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠈⠢⡀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠈⠢⡀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠈⠢⡀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠈⠢⡀\n\njulia> fock(20, 4)' * a_d * fock(20, 3)\n2.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sigmap","page":"API","title":"QuantumToolbox.sigmap","text":"sigmap()\n\nPauli ladder operator hatsigma_+ = hatsigma_x + i hatsigma_y.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sigmam","page":"API","title":"QuantumToolbox.sigmam","text":"sigmam()\n\nPauli ladder operator hatsigma_- = hatsigma_x - i hatsigma_y.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sigmax","page":"API","title":"QuantumToolbox.sigmax","text":"sigmax()\n\nPauli operator hatsigma_x = hatsigma_- + hatsigma_+.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sigmay","page":"API","title":"QuantumToolbox.sigmay","text":"sigmay()\n\nPauli operator hatsigma_y = i left( hatsigma_- - hatsigma_+ right).\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sigmaz","page":"API","title":"QuantumToolbox.sigmaz","text":"sigmaz()\n\nPauli operator hatsigma_z = commhatsigma_+hatsigma_-.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.eye","page":"API","title":"QuantumToolbox.eye","text":"eye(N::Int; type=OperatorQuantumObject, dims=[N])\n\nIdentity operator hatmathbb1 with Hilbert dimension N.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.qeye","page":"API","title":"QuantumToolbox.qeye","text":"qeye(N::Int; type=OperatorQuantumObject, dims=[N])\n\nIdentity operator hatmathbb1 with Hilbert dimension N.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.fock","page":"API","title":"QuantumToolbox.fock","text":"fock(N::Int, pos::Int; dims::Vector{Int}=[N], sparse::Bool=false)\n\nGenerates a fock state ketpsi of dimension N. It is also possible to specify the list of dimensions dims if different subsystems are present.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.basis","page":"API","title":"QuantumToolbox.basis","text":"basis(N::Int, pos::Int; dims::Vector{Int}=[N])\n\nGenerates a fock state like fock.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.coherent","page":"API","title":"QuantumToolbox.coherent","text":"coherent(N::Real, α::T)\n\nGenerates a coherent state ketalpha, which is defined as an eigenvector of the bosonic annihilation operator hata ketalpha = alpha ketalpha.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.rand_dm","page":"API","title":"QuantumToolbox.rand_dm","text":"rand_dm(N::Integer; kwargs...)\n\nGenerates a random density matrix hatrho, with the property to be positive definite, and that Tr left hatrho right = 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.projection","page":"API","title":"QuantumToolbox.projection","text":"projection(N::Int, i::Int, j::Int)\n\nGenerates the projection operator hatO = dyadij with Hilbert space dimension N.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sinm","page":"API","title":"QuantumToolbox.sinm","text":"sinm(O::QuantumObject)\n\nGenerates the sine of the operator O, defined as\n\nsin left( hatO right) = frace^i hatO - e^-i hatO2 i\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.cosm","page":"API","title":"QuantumToolbox.cosm","text":"cosm(O::QuantumObject)\n\nGenerates the cosine of the operator O, defined as\n\ncos left( hatO right) = frace^i hatO + e^-i hatO2\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Time-evolution","page":"API","title":"Time evolution","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"sesolveProblem\nmesolveProblem\nlr_mesolveProblem\nmcsolveProblem\nmcsolveEnsembleProblem\nsesolve\nmesolve\nlr_mesolve\nmcsolve\ndfd_mesolve\ndsf_mesolve\ndsf_mcsolve\nliouvillian\nliouvillian_generalized\nsteadystate_floquet","category":"page"},{"location":"api/#QuantumToolbox.sesolveProblem","page":"API","title":"QuantumToolbox.sesolveProblem","text":"sesolveProblem(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector;\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5()\n    e_ops::AbstractVector=[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    kwargs...)\n\nGenerates the ODEProblem for the Schrödinger time evolution of a quantum system.\n\nArguments\n\nH::QuantumObject: The Hamiltonian of the system.\nψ0::QuantumObject: The initial state of the system.\nt_l::AbstractVector: The time list of the evolution.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm: The algorithm used for the time evolution.\ne_ops::AbstractVector: The list of operators to be evaluated during the evolution.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: The time-dependent Hamiltonian of the system. If nothing, the Hamiltonian is time-independent.\nparams::NamedTuple: The parameters of the system.\nkwargs...: The keyword arguments passed to the ODEProblem constructor.\n\nReturns\n\nprob: The ODEProblem for the Schrödinger time evolution of the system.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mesolveProblem","page":"API","title":"QuantumToolbox.mesolveProblem","text":"mesolveProblem(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector, c_ops::AbstractVector=[];\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::AbstractVector=[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    kwargs...)\n\nGenerates the ODEProblem for the master equation time evolution of an open quantum system.\n\nArguments\n\nH::QuantumObject: The Hamiltonian or the Liouvillian of the system.\nψ0::QuantumObject: The initial state of the system.\nt_l::AbstractVector: The time list of the evolution.\nc_ops::AbstractVector=[]: The list of the collapse operators.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(): The algorithm used for the time evolution.\ne_ops::AbstractVector=[]: The list of the operators for which the expectation values are calculated.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing: The time-dependent Hamiltonian or Liouvillian.\nparams::NamedTuple=NamedTuple(): The parameters of the time evolution.\nkwargs...: The keyword arguments for the ODEProblem.\n\nReturns\n\nprob::ODEProblem: The ODEProblem for the master equation time evolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.lr_mesolveProblem","page":"API","title":"QuantumToolbox.lr_mesolveProblem","text":"lr_mesolveProblem(H, z, B, t_l, c_ops; e_ops=(), f_ops=(), opt=LRMesolveOptions(), kwargs...) where T\nFormulates the ODEproblem for the low-rank time evolution of the system. The function is called by lr_mesolve.\n\nParameters\n----------\nH : QuantumObject\n    The Hamiltonian of the system.\nz : AbstractMatrix{T}\n    The initial z matrix.\nB : AbstractMatrix{T}\n    The initial B matrix.\nt_l : AbstractVector{T}\n    The time steps at which the expectation values and function values are calculated.\nc_ops : AbstractVector{QuantumObject}\n    The jump operators of the system.\ne_ops : Tuple{QuantumObject}\n    The operators whose expectation values are calculated.\nf_ops : Tuple{Function}\n    The functions whose values are calculated.\nopt : LRMesolveOptions\n    The options of the problem.\nkwargs : NamedTuple\n    Additional keyword arguments for the ODEProblem.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mcsolveProblem","page":"API","title":"QuantumToolbox.mcsolveProblem","text":"mcsolveProblem(H::QuantumObject{<:AbstractArray{T1},OperatorQuantumObject},\n    ψ0::QuantumObject{<:AbstractArray{T2},KetQuantumObject},\n    t_l::AbstractVector,\n    c_ops::Vector{QuantumObject{Tc, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[];\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Vector{QuantumObject{Te, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    jump_callback::TJC=ContinuousLindbladJumpCallback(),\n    kwargs...)\n\nGenerates the ODEProblem for a single trajectory of the Monte Carlo wave function time evolution of an open quantum system.\n\nArguments\n\nH::QuantumObject: Hamiltonian of the system.\nψ0::QuantumObject: Initial state of the system.\nt_l::AbstractVector: List of times at which to save the state of the system.\nc_ops::Vector: List of collapse operators.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm: Algorithm to use for the time evolution.\ne_ops::Vector: List of operators for which to calculate expectation values.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: Time-dependent part of the Hamiltonian.\nparams::NamedTuple: Dictionary of parameters to pass to the solver.\nseeds::Union{Nothing, Vector{Int}}: List of seeds for the random number generator. Length must be equal to the number of trajectories provided.\njump_callback::LindbladJumpCallbackType: The Jump Callback type: Discrete or Continuous.\nkwargs...: Additional keyword arguments to pass to the solver.\n\nReturns\n\nprob::ODEProblem: The ODEProblem for the Monte Carlo wave function time evolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mcsolveEnsembleProblem","page":"API","title":"QuantumToolbox.mcsolveEnsembleProblem","text":"mcsolveEnsembleProblem(H::QuantumObject{<:AbstractArray{T1},OperatorQuantumObject},\n    ψ0::QuantumObject{<:AbstractArray{T2},KetQuantumObject},\n    t_l::AbstractVector,\n    c_ops::Vector{QuantumObject{Tc, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[];\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Vector{QuantumObject{Te, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    jump_callback::TJC=ContinuousLindbladJumpCallback(),\n    prob_func::Function=_mcsolve_prob_func,\n    output_func::Function=_mcsolve_output_func,\n    kwargs...)\n\nGenerates the ODEProblem for an ensemble of trajectories of the Monte Carlo wave function time evolution of an open quantum system.\n\nArguments\n\nH::QuantumObject: Hamiltonian of the system.\nψ0::QuantumObject: Initial state of the system.\nt_l::AbstractVector: List of times at which to save the state of the system.\nc_ops::Vector: List of collapse operators.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm: Algorithm to use for the time evolution.\ne_ops::Vector: List of operators for which to calculate expectation values.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: Time-dependent part of the Hamiltonian.\nparams::NamedTuple: Dictionary of parameters to pass to the solver.\nseeds::Union{Nothing, Vector{Int}}: List of seeds for the random number generator. Length must be equal to the number of trajectories provided.\njump_callback::LindbladJumpCallbackType: The Jump Callback type: Discrete or Continuous.\nprob_func::Function: Function to use for generating the ODEProblem.\noutput_func::Function: Function to use for generating the output of a single trajectory.\nkwargs...: Additional keyword arguments to pass to the solver.\n\nReturns\n\nprob::EnsembleProblem with ODEProblem: The Ensemble ODEProblem for the Monte Carlo\n\nwave function time evolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sesolve","page":"API","title":"QuantumToolbox.sesolve","text":"sesolve(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector;\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::AbstractVector=[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    kwargs...)\n\nTime evolution of a closed quantum system using the Schrödinger equation.\n\nArguments\n\nH::QuantumObject: Hamiltonian of the system.\nψ0::QuantumObject: Initial state of the system.\nt_l::AbstractVector: List of times at which to save the state of the system.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm: Algorithm to use for the time evolution.\ne_ops::AbstractVector: List of operators for which to calculate expectation values.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: Time-dependent part of the Hamiltonian.\nparams::NamedTuple: Dictionary of parameters to pass to the solver.\nkwargs...: Additional keyword arguments to pass to the solver.\nReturns\nsol::TimeEvolutionSol: The solution of the time evolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mesolve","page":"API","title":"QuantumToolbox.mesolve","text":"mesolve(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector, c_ops::AbstractVector=[];\n    alg::OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::AbstractVector=[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    kwargs...)\n\nTime evolution of an open quantum system using master equation.\n\nArguments\n\nH::QuantumObject: Hamiltonian of Liouvillian of the system.\nψ0::QuantumObject: Initial state of the system.\nt_l::AbstractVector: List of times at which to save the state of the system.\nc_ops::AbstractVector: List of collapse operators.\nalg::OrdinaryDiffEqAlgorithm: Algorithm to use for the time evolution.\ne_ops::AbstractVector: List of operators for which to calculate expectation values.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: Time-dependent part of the Hamiltonian.\nparams::NamedTuple: Named Tuple of parameters to pass to the solver.\nkwargs...: Additional keyword arguments to pass to the solver.\n\nReturns\n\nsol::TimeEvolutionSol: The solution of the time evolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.lr_mesolve","page":"API","title":"QuantumToolbox.lr_mesolve","text":"lr_mesolve(prob::ODEProblem; kwargs...)\nSolves the ODEProblem formulated by lr_mesolveProblem. The function is called by lr_mesolve.\n\nParameters\n----------\nprob : ODEProblem\n    The ODEProblem formulated by lr_mesolveProblem.\nkwargs : NamedTuple\n    Additional keyword arguments for the ODEProblem.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mcsolve","page":"API","title":"QuantumToolbox.mcsolve","text":"mcsolve(H::QuantumObject{<:AbstractArray{T1},OperatorQuantumObject},\n    ψ0::QuantumObject{<:AbstractArray{T2},KetQuantumObject},\n    t_l::AbstractVector,\n    c_ops::Vector{QuantumObject{Tc, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[];\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Vector{QuantumObject{Te, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    n_traj::Int=1,\n    ensemble_method=EnsembleThreads(),\n    jump_callback::TJC=ContinuousLindbladJumpCallback(),\n    kwargs...)\n\nTime evolution of an open quantum system using quantum trajectories.\n\nArguments\n\nH::QuantumObject: Hamiltonian of the system.\nψ0::QuantumObject: Initial state of the system.\nt_l::AbstractVector: List of times at which to save the state of the system.\nc_ops::Vector: List of collapse operators.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm: Algorithm to use for the time evolution.\ne_ops::Vector: List of operators for which to calculate expectation values.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: Time-dependent part of the Hamiltonian.\nparams::NamedTuple: Dictionary of parameters to pass to the solver.\nseeds::Union{Nothing, Vector{Int}}: List of seeds for the random number generator. Length must be equal to the number of trajectories provided.\nn_traj::Int: Number of trajectories to use.\nensemble_method: Ensemble method to use.\njump_callback::LindbladJumpCallbackType: The Jump Callback type: Discrete or Continuous.\nprob_func::Function: Function to use for generating the ODEProblem.\noutput_func::Function: Function to use for generating the output of a single trajectory.\nkwargs...: Additional keyword arguments to pass to the solver.\n\nReturns\n\nsol::TimeEvolutionMCSol: The solution of the time evolution.\n\nNotes\n\nensemble_method can be one of EnsembleThreads(), EnsembleSerial(), EnsembleDistributed().\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.dfd_mesolve","page":"API","title":"QuantumToolbox.dfd_mesolve","text":"function dfd_mesolve(H::Function, ψ0::QuantumObject,\n    t_l::AbstractVector, c_ops::Function, maxdims::AbstractVector,\n    dfd_params::NamedTuple=NamedTuple();\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Function=(dim_list) -> Vector{Vector{T1}}([]),\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    tol_list::Vector{<:Number}=fill(1e-8, length(maxdims)),\n    kwargs...)\n\nTime evolution of an open quantum system using master equation, dynamically changing the dimension of the Hilbert subspaces.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.dsf_mesolve","page":"API","title":"QuantumToolbox.dsf_mesolve","text":"function dsf_mesolve(H::Function,\n    ψ0::QuantumObject,\n    t_l::AbstractVector, c_ops::Function,\n    op_list::Vector{TOl},\n    α0_l::Vector{<:Number}=zeros(length(op_list)),\n    dsf_params::NamedTuple=NamedTuple();\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Function=(op_list,p) -> Vector{TOl}([]),\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    δα_list::Vector{<:Number}=fill(0.2, length(op_list)),\n    krylov_dim::Int=min(5,cld(length(ket2dm(ψ0).data), 3)),\n    kwargs...)\n\nTime evolution of an open quantum system using master equation and the Dynamical Shifted Fock algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.dsf_mcsolve","page":"API","title":"QuantumToolbox.dsf_mcsolve","text":"function dsf_mcsolve(H::Function,\n    ψ0::QuantumObject,\n    t_l::AbstractVector, c_ops::Function,\n    op_list::Vector{TOl},\n    α0_l::Vector{<:Number}=zeros(length(op_list)),\n    dsf_params::NamedTuple=NamedTuple();\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Function=(op_list,p) -> Vector{TOl}([]),\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    δα_list::Vector{<:Real}=fill(0.2, length(op_list)),\n    n_traj::Int=1,\n    ensemble_method=EnsembleThreads(),\n    jump_callback::LindbladJumpCallbackType=ContinuousLindbladJumpCallback(),\n    krylov_dim::Int=min(5,cld(length(ψ0.data), 3)),\n    kwargs...)\n\nTime evolution of a quantum system using the Monte Carlo wave function method and the Dynamical Shifted Fock algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.liouvillian","page":"API","title":"QuantumToolbox.liouvillian","text":"liouvillian(H::QuantumObject, c_ops::AbstractVector, Id_cache=I(prod(H.dims))\n\nConstruct the Liouvillian superoperator for a system Hamiltonian and a set of collapse operators: mathcalL cdot = -ihatH cdot + sum_i mathcalDhatO_i cdot, where mathcalDhatO_i cdot = hatO_i cdot hatO_i^dagger - frac12 hatO_i^dagger hatO_i cdot - frac12 cdot hatO_i^dagger hatO_i.\n\nThe optional argument Id_cache can be used to pass a precomputed identity matrix. This can be useful when the same function is applied multiple times with a known Hilbert space dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.liouvillian_generalized","page":"API","title":"QuantumToolbox.liouvillian_generalized","text":"liouvillian_generalized(H::QuantumObject, fields::Vector, \nT_list::Vector; N_trunc::Int=size(H,1), tol::Float64=0.0, σ_filter::Union{Nothing, Real}=nothing)\n\nConstructs the generalized Liouvillian for a system coupled to a bath of harmonic oscillators.\n\nSee, e.g., Settineri, Alessio, et al. \"Dissipation and thermal noise in hybrid quantum systems in the ultrastrong-coupling regime.\" Physical Review A 98.5 (2018): 053834.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.steadystate_floquet","page":"API","title":"QuantumToolbox.steadystate_floquet","text":"steadystate_floquet(H_0::QuantumObject,\n    c_ops::Vector, H_p::QuantumObject,\n    H_m::QuantumObject,\n    ω::Real; n_max::Int=4, lf_solver::LSolver=LiouvillianDirectSolver(),\n    ss_solver::Type{SSSolver}=SteadyStateDirectSolver)\n\nCalculates the steady state of a periodically driven system. Here H_0 is the Hamiltonian or the Liouvillian of the undriven system. Considering a monochromatic drive at frequency omega, we divide it into two parts, H_p and H_m, where H_p oscillates as e^i omega t and H_m oscillates as e^-i omega t. n_max is the number of iterations used to obtain the effective Liouvillian, lf_solver is the solver used to solve the effective Liouvillian, and ss_solver is the solver used to solve the steady state.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Correlations-and-Spectrum","page":"API","title":"Correlations and Spectrum","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"correlation_3op_2t\ncorrelation_2op_2t\ncorrelation_2op_1t\nspectrum","category":"page"},{"location":"api/#QuantumToolbox.correlation_3op_2t","page":"API","title":"QuantumToolbox.correlation_3op_2t","text":"correlation_3op_2t(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector,\n    τ_l::AbstractVector,\n    A::QuantumObject,\n    B::QuantumObject,\n    C::QuantumObject,\n    c_ops::AbstractVector=[];\n    kwargs...)\n\nReturns the two-times correlation function of three operators hatA, hatB and hatC: expvalhatA(t) hatB(t + tau) hatC(t) for a given initial state ketpsi_0.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.correlation_2op_2t","page":"API","title":"QuantumToolbox.correlation_2op_2t","text":"correlation_2op_2t(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector,\n    τ_l::AbstractVector,\n    A::QuantumObject,\n    B::QuantumObject,\n    c_ops::AbstractVector=[];\n    reverse::Bool=false,\n    kwargs...)\n\nReturns the two-times correlation function of two operators hatA and hatBat different times\\expval{\\hat{A}(t + \\tau) \\hat{B}(t)}. Whenreverse=true, the correlation function is calculated as\\expval{\\hat{A}(t) \\hat{B}(t + \\tau)}`.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.correlation_2op_1t","page":"API","title":"QuantumToolbox.correlation_2op_1t","text":"correlation_2op_1t(H::QuantumObject,\n    ψ0::QuantumObject,\n    τ_l::AbstractVector,\n    A::QuantumObject,\n    B::QuantumObject,\n    c_ops::AbstractVector=[];\n    reverse::Bool=false,\n    kwargs...)\n\nReturns the one-time correlation function of two operators hatA and hatB  at different times expvalhatA(tau) hatB(0). When reverse=true, the correlation function is calculated as expvalhatA(0) hatB(tau).\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spectrum","page":"API","title":"QuantumToolbox.spectrum","text":"spectrum(H::QuantumObject,\nω_list::AbstractVector,\nA::QuantumObject{<:AbstractArray{T2},OperatorQuantumObject},\nB::QuantumObject{<:AbstractArray{T3},OperatorQuantumObject},\nc_ops::AbstractVector=[];\nsolver::MySolver=ExponentialSeries(),\n    kwargs...)\n\nReturns the emission spectrum S(omega) = int_-infty^infty expvalhatA(tau) hatB(0) e^-i omega tau d tau.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Eigenvalues-and-eigenvectors","page":"API","title":"Eigenvalues and eigenvectors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LinearAlgebra.eigen\nLinearAlgebra.eigvals\neigsolve\neigsolve_al","category":"page"},{"location":"api/#LinearAlgebra.eigen","page":"API","title":"LinearAlgebra.eigen","text":"LinearAlgebra.eigen(A::QuantumObject; kwargs...)\n\nCalculates the eigenvalues and eigenvectors of the QuantumObject A using the Julia LinearAlgebra package.\n\njulia> a = destroy(5);\n\njulia> H = a + a'\nQuantum Object:   type=Operator   dims=[5]   size=(5, 5)   ishermitian=true\n5×5 SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n     ⋅          1.0+0.0im          ⋅              ⋅          ⋅\n 1.0+0.0im          ⋅      1.41421+0.0im          ⋅          ⋅\n     ⋅      1.41421+0.0im          ⋅      1.73205+0.0im      ⋅\n     ⋅              ⋅      1.73205+0.0im          ⋅      2.0+0.0im\n     ⋅              ⋅              ⋅          2.0+0.0im      ⋅\n\njulia> E, U = eigen(H)\nEigen{ComplexF64, Float64, Matrix{ComplexF64}, Vector{Float64}}\nvalues:\n5-element Vector{Float64}:\n -2.8569700138728\n -1.3556261799742608\n  1.3322676295501878e-15\n  1.3556261799742677\n  2.8569700138728056\nvectors:\n5×5 Matrix{ComplexF64}:\n  0.106101+0.0im  -0.471249-0.0im  …   0.471249-0.0im  0.106101-0.0im\n -0.303127-0.0im   0.638838+0.0im      0.638838+0.0im  0.303127-0.0im\n  0.537348+0.0im  -0.279149-0.0im      0.279149-0.0im  0.537348-0.0im\n -0.638838-0.0im  -0.303127-0.0im     -0.303127-0.0im  0.638838+0.0im\n  0.447214+0.0im   0.447214+0.0im     -0.447214-0.0im  0.447214-0.0im\n\njulia> ψ_1 = QuantumObject(U[:,1], dims=H.dims);\n\njulia> expect(H, ψ_1) ≈ E[1]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.eigvals","page":"API","title":"LinearAlgebra.eigvals","text":"LinearAlgebra.eigvals(A::QuantumObject; kwargs...)\n\nSame as eigen(A::QuantumObject; kwargs...) but for only the eigenvalues.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.eigsolve","page":"API","title":"QuantumToolbox.eigsolve","text":"function eigsolve(A::QuantumObject; v0::Union{Nothing,AbstractVector}=nothing, \n    sigma::Union{Nothing, Real}=nothing, k::Int = min(4, size(A, 1)), \n    krylovdim::Int = min(10, size(A, 1)), tol::Real = 1e-8, maxiter::Int = 200,\n    solver::Union{Nothing, LinearSolve.SciMLLinearSolveAlgorithm} = nothing, kwargs...)\n\nSolve for the eigenvalues and eigenvectors of a matrix A using the Arnoldi method. The keyword arguments are passed to the linear solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.eigsolve_al","page":"API","title":"QuantumToolbox.eigsolve_al","text":"eigsolve_al(H::QuantumObject,\n    T::Real, c_ops::AbstractVector=[];\n    alg::OrdinaryDiffEqAlgorithm=Tsit5(),\n    H_t::Union{Nothing,Function}=nothing,\n    params::NamedTuple=NamedTuple(),\n    progress::Bool=true,\n    ρ0::Union{Nothing, AbstractMatrix} = nothing,\n    k::Int=1,\n    krylovdim::Int=min(10, size(H, 1)),\n    maxiter::Int=200,\n    eigstol::Real=1e-6,\n    kwargs...)\n\nSolve the eigenvalue problem for a Liouvillian superoperator L using the Arnoldi-Lindblad method.\n\nArguments\n\nH: The Hamiltonian (or directly the Liouvillian) of the system.\nT: The time at which to evaluate the time evolution\nc_ops: A vector of collapse operators\nalg: The differential equation solver algorithm\nH_t: A function H_t(t) that returns the additional term at time t\nparams: A dictionary of additional parameters\nρ0: The initial density matrix. If not specified, a random density matrix is used\nk: The number of eigenvalues to compute\nkrylovdim: The dimension of the Krylov subspace\nmaxiter: The maximum number of iterations for the eigsolver\neigstol: The tolerance for the eigsolver\nkwargs: Additional keyword arguments passed to the differential equation solver\n\nReturns\n\nEigsolveResult: A struct containing the eigenvalues, the eigenvectors, and some information about the eigsolver\n\nReferences\n\n[1] Minganti, F., & Huybrechts, D. (2022). Arnoldi-Lindblad time evolution: \n\nFaster-than-the-clock algorithm for the spectrum of time-independent  and Floquet open quantum systems. Quantum, 6, 649.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Low-Rank-internal-APIs","page":"API","title":"Low Rank internal APIs","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"_calculate_expectation!\n_adjM_condition_variational\n_adjM_affect!\n_adjM_condition_ratio\n_pinv!\ndBdz!","category":"page"},{"location":"api/#QuantumToolbox._calculate_expectation!","page":"API","title":"QuantumToolbox._calculate_expectation!","text":"_calculate_expectation!(p,z,B,idx) where T\nCalculates the expectation values and function values of the operators and functions in p.e_ops and p.f_ops, respectively, and stores them in p.expvals and p.funvals.\nThe function is called by the callback _save_affect_lr_mesolve!.\n\nParameters\n----------\np : NamedTuple\n    The parameters of the problem.\nz : AbstractMatrix{T}\n    The z matrix.\nB : AbstractMatrix{T}\n    The B matrix.\nidx : Integer\n    The index of the current time step.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox._adjM_condition_variational","page":"API","title":"QuantumToolbox._adjM_condition_variational","text":"_adjM_condition_variational(u, t, integrator) where T\nCondition for the dynamical rank adjustment based on the leakage out of the low-rank manifold.\n\nParameters\n----------\nu : AbstractVector{T}\n    The current state of the system.\nt : Real\n    The current time.\nintegrator : ODEIntegrator\n    The integrator of the problem.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox._adjM_affect!","page":"API","title":"QuantumToolbox._adjM_affect!","text":"_adjM_affect!(integrator)\nAffect function for the dynamical rank adjustment. It increases the rank of the low-rank manifold by one, and updates the matrices accordingly.\nIf Δt>0, it rewinds the integrator to the previous time step.\n\nParameters\n----------\nintegrator : ODEIntegrator\n    The integrator of the problem.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox._adjM_condition_ratio","page":"API","title":"QuantumToolbox._adjM_condition_ratio","text":"_adjM_condition_ratio(u, t, integrator) where T\nCondition for the dynamical rank adjustment based on the ratio between the smallest and largest eigenvalues of the density matrix.\nThe spectrum of the density matrix is calculated efficiently using the properties of the SVD decomposition of the matrix.\n\nParameters\n----------\nu : AbstractVector{T}\n    The current state of the system.\nt : Real\n    The current time.\nintegrator : ODEIntegrator\n    The integrator of the problem.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox._pinv!","page":"API","title":"QuantumToolbox._pinv!","text":"_pinv!(A, T1, T2; atol::Real=0.0, rtol::Real=(eps(real(float(oneunit(T))))*min(size(A)...))*iszero(atol)) where T\nComputes the pseudo-inverse of a matrix A, and stores it in T1. If T2 is provided, it is used as a temporary matrix. \nThe algorithm is based on the SVD decomposition of A, and is taken from the Julia package LinearAlgebra.\nThe difference with respect to the original function is that the cutoff is done with a smooth function instead of a step function.\n\nParameters\n----------\nA : AbstractMatrix{T}\n    The matrix to be inverted.\nT1 : AbstractMatrix{T}\nT2 : AbstractMatrix{T}\n    Temporary matrices used in the calculation.\natol : Real\n    Absolute tolerance for the calculation of the pseudo-inverse.   \nrtol : Real\n    Relative tolerance for the calculation of the pseudo-inverse.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.dBdz!","page":"API","title":"QuantumToolbox.dBdz!","text":"dBdz!(du, u, p, t) where T\nDynamical evolution equations for the low-rank manifold. The function is called by the ODEProblem.\n\nParameters\n----------\ndu : AbstractVector{T}\n    The derivative of the state of the system.\nu : AbstractVector{T}\n    The current state of the system.\np : NamedTuple\n    The parameters of the problem.\nt : Real\n    The current time.\n\n\n\n\n\n","category":"function"},{"location":"lowrank/#Low-Rank-Master-Equation","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"","category":"section"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"We start by importing the packages","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"using Plots\nusing LaTeXStrings\nusing QuantumToolbox;","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define lattice","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Nx, Ny = 2, 3\nlatt = Lattice(Nx=Nx, Ny=Ny)","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define lr-space dimensions","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"N_cut = 2         # Number of states of each mode\nN_modes = latt.N  # Number of modes\nN = N_cut^N_modes # Total number of states\nM = Nx*Ny+1       # Number of states in the LR basis","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define lr states. Take as initial state all spins up. All other N states are taken as those with miniman Hamming distance to the initial state.","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"ϕ = Vector{QuantumObject{Vector{ComplexF64}, KetQuantumObject}}(undef, M)\nϕ[1] = kron(repeat([basis(2,0)],N_modes)...)\n\nglobal i=1\nfor j in 1:N_modes\n    global i+=1\n    i<=M && (ϕ[i] = mb(sp, j, latt) * ϕ[1])\nend\nfor k in 1:N_modes-1\n    for l=k+1:N_modes\n        global i+=1\n        i<=M && (ϕ[i] = mb(sp, k, latt) * mb(sp, l, latt) * ϕ[1])\n    end\nend\nfor i in i+1:M\n    ϕ[i] = QuantumObject(rand(ComplexF64,size(ϕ[1])[1]), dims=ϕ[1].dims)\n    normalize!(ϕ[i])\nend","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define the initial state","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"z  = hcat(broadcast(x->x.data, ϕ)...)\np0 = 0. # Population of the lr states other than the initial state\nB  = Matrix(Diagonal([1+0im; p0 * ones(M-1)]))\nS  = z'*z # Overlap matrix\nB = B / tr(S*B) # Normalize B\n\nρ = QuantumObject(z*B*z', dims=ones(Int,N_modes)*N_cut); # Full density matrix","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define the Hamiltonian and collapse operators","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"# Define Hamiltonian and collapse operators\nJx = 0.9 \nJy = 1.04\nJz = 1. \nhx = 0.\nγ  = 1\n\nSx = sum([mb(sx, i, latt) for i in 1:latt.N])\nSy = sum([mb(sy, i, latt) for i in 1:latt.N])\nSz = sum([mb(sz, i, latt) for i in 1:latt.N])\nSFxx = sum([mb(sx, i, latt) * mb(sx, j, latt) for i in 1:latt.N for j in 1:latt.N])\n\nH, c_ops = TFIM(Jx, Jy, Jz, hx, γ, latt; bc=pbc, order=1)\ne_ops = (Sx,Sy,Sz,SFxx)\n\ntl = LinRange(0,10,100);","category":"page"},{"location":"lowrank/#Full-evolution","page":"Low Rank Master Equation","title":"Full evolution","text":"","category":"section"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"@time mesol = mesolve(H, ρ, tl, c_ops; e_ops=[e_ops...]);\nA = Matrix(mesol.states[end].data)\nλ = eigvals(Hermitian(A))\nStrue  = -sum(λ.*log2.(λ))/latt.N;","category":"page"},{"location":"lowrank/#Low-Rank-evolution","page":"Low Rank Master Equation","title":"Low Rank evolution","text":"","category":"section"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define functions to be evaluated during the low-rank evolution","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"function f_purity(p,z,B)\n    N  = p.N\n    M  = p.M\n    S  = p.S\n    T  = p.temp_MM\n\n    mul!(T, S, B)\n    tr(T^2)\nend\n\nfunction f_trace(p,z,B)\n    N  = p.N\n    M  = p.M\n    S  = p.S\n    T  = p.temp_MM\n\n    mul!(T,S,B)\n    tr(T)\nend\n\nfunction f_entropy(p,z,B)\n    C = p.A0\n    σ = p.Bi\n\n    mul!(C, z, sqrt(B))\n    mul!(σ, C', C)\n    λ = eigvals(Hermitian(σ))\n    λ = λ[λ.>1e-10]\n    return -sum(λ .* log2.(λ))\nend;","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define the options for the low-rank evolution","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"opt = LRMesolveOptions( \n    alg        = Tsit5(),\n    err_max    = 1e-3,\n    p0         = 0.,\n    atol_inv   = 1e-6,\n    adj_condition=\"variational\",\n    Δt = 0.\n);\n\n@time lrsol = lr_mesolve(H, z, B, tl, c_ops; e_ops=e_ops, f_ops=(f_purity, f_entropy, f_trace,), opt=opt);","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Plot the results","category":"page"},{"location":"lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"fig = plot(layout=(1,2), size=(800,400), legend=:topleft, xlabel=L\"\\gamma t\")\n\nm_me = real(mesol.expect[3,:])/Nx/Ny\nm_lr = real(lrsol.expvals[3,:])/Nx/Ny\n\nplot!(fig[1], tl, m_lr, label=raw\"LR $[M=M(t)]$\", lw=2)\nplot!(fig[1], tl, m_me, ls=:dash, label=\"Fock\", lw=2)\nylabel!(fig[1], L\"M_{z}\")\n\nplot!(fig[2], tl, 1 .-real(lrsol.funvals[1,:]), label=L\"$1-P$\", lw=2)\nplot!(fig[2], tl, 1 .-real(lrsol.funvals[3,:]), c=:orange, label=L\"$1-\\rm{Tr}(\\rho)$\", lw=2, ls=:dash)\nplot!(fig[2], tl, real(lrsol.funvals[2,:])/Nx/Ny, c=:blue, label=L\"S\", lw=2)\nhline!(fig[2], [Strue], c=:blue, ls=:dash, lw=2, label=L\"S^{\\rm \\,true}_{\\rm ss}\")\nylabel!(fig[2], \"value\")\nxlabel!(fig[2], L\"\\gamma t\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = QuantumToolbox","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumToolbox is a Julia package for numerical simulation of quantum systems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
