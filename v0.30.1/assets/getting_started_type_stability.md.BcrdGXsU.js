import{_ as t,c as e,o as p,ai as i,j as a,a as n}from"./chunks/framework.CSM7S0B-.js";const C=JSON.parse('{"title":"The Importance of Type-Stability","description":"","frontmatter":{},"headers":[],"relativePath":"getting_started/type_stability.md","filePath":"getting_started/type_stability.md","lastUpdated":null}'),l={name:"getting_started/type_stability.md"},h={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},o={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.332ex"},xmlns:"http://www.w3.org/2000/svg",width:"3.524ex",height:"2.732ex",role:"img",focusable:"false",viewBox:"0 -1060.7 1557.7 1207.4","aria-hidden":"true"},r={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},k={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.441ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 1079 1000","aria-hidden":"true"};function d(c,s,g,y,u,E){return p(),e("div",null,[s[18]||(s[18]=i(`<h1 id="doc:Type-Stability" tabindex="-1">The Importance of Type-Stability <a class="header-anchor" href="#doc:Type-Stability" aria-label="Permalink to &quot;The Importance of Type-Stability {#doc:Type-Stability}&quot;">​</a></h1><p>You are here because you have probably heard about the excellent performance of Julia compared to other common programming languages like Python. One of the reasons is the Just-In-Time (JIT) compiler of Julia, which is able to generate highly optimized machine code. However, the JIT compiler can only do its job if the code type can be inferred. You can also read the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/" target="_blank" rel="noreferrer">Performance Tips</a> section in Julia&#39;s documentation for more details. Here, we try to explain it briefly, with a focus on the <code>QuantumToolbox.jl</code> package.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>This page is not a tutorial on <code>QuantumToolbox.jl</code>, but rather a general guide to writing Julia code for simulating quantum systems efficiently. If you don&#39;t care about the performance of your code, you can skip this page.</p></div><h2 id="Basics-of-type-stability" tabindex="-1">Basics of type stability <a class="header-anchor" href="#Basics-of-type-stability" aria-label="Permalink to &quot;Basics of type stability {#Basics-of-type-stability}&quot;">​</a></h2><p>Let&#39;s have a look at the following example:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>The function <code>foo</code> apparently seems to be innocent. It takes an argument <code>x</code> and returns either <code>1</code> or <code>-1.0</code> depending on the sign of <code>x</code>. However, the return type of <code>foo</code> is not clear. If <code>x</code> is positive, the return type is <code>Int</code>, otherwise it is <code>Float64</code>. This is a problem for the JIT compiler, because it has to determine the return type of <code>foo</code> at runtime. This is called type instability (even though it is a weak form) and may lead to a significant performance penalty. To avoid this, always aim for type-stable code. This means that the return type of a function should be clear from the types of its arguments. We can check the inferred return type of <code>foo</code> using the <code>@code_warntype</code> macro:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@code_warntype</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MethodInstance for Main.var&quot;Main&quot;.foo(::Int64)</span></span>
<span class="line"><span>  from foo(x) @ Main.var&quot;Main&quot; type_stability.md:18</span></span>
<span class="line"><span>Arguments</span></span>
<span class="line"><span>  #self#::Core.Const(Main.var&quot;Main&quot;.foo)</span></span>
<span class="line"><span>  x::Int64</span></span>
<span class="line"><span>Body::UNION{FLOAT64, INT64}</span></span>
<span class="line"><span>1 ─ %1 = Main.var&quot;Main&quot;.:&gt;::Core.Const(&gt;)</span></span>
<span class="line"><span>│   %2 = (%1)(x, 0)::Bool</span></span>
<span class="line"><span>└──      goto #3 if not %2</span></span>
<span class="line"><span>2 ─      return 1</span></span>
<span class="line"><span>3 ─      return -1.0</span></span></code></pre></div><p>The key point is to ensure the return type of a function is clear from the types of its arguments. There are several ways to achieve this, and the best approach depends on the specific problem. For example, one can use the same return type:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>Or you can ensure the return type matches the type of the argument:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>The latter example is very important because it takes advantage of Julia&#39;s multiple dispatch, which is one of the most powerful features of the language. Depending on the type <code>T</code> of the argument <code>x</code>, the Julia compiler generates a specialized version of <code>foo</code> that is optimized for this type. If the input type is an <code>Int64</code>, the return type is <code>Int64</code>, if <code>x</code> is a <code>Float64</code>, the return type is <code>Float64</code>, and so on.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">//</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>foo(1) = 1</span></span>
<span class="line"><span>foo(-4.4) = -1.0</span></span>
<span class="line"><span>foo(1 // 2) = 1//1</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">Note</p><p>If you didn&#39;t know how to make this function type-stable, it is probably a good idea to read the official Julia documentation, and in particular its <a href="https://docs.julialang.org/en/v1/manual/performance-tips/" target="_blank" rel="noreferrer">Performance Tips</a> section.</p></div><h2 id="Global-variables" tabindex="-1">Global variables <a class="header-anchor" href="#Global-variables" aria-label="Permalink to &quot;Global variables {#Global-variables}&quot;">​</a></h2><p>Another source of type instability is the use of global variables. In general, it is a good idea to declare global variables as <code>const</code> to ensure their type is fixed for the entire program. For example, consider the following function that internally takes a global variable <code>y</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.4</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> zero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># this returns the zero of the same type of x</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>The Julia compiler cannot infer the type of <code>res</code> because it depends on the type of <code>y</code>, which is a global variable that can change at any time of the program. We can check it using the <code>@code_warntype</code> macro:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@code_warntype</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MethodInstance for Main.var&quot;Main&quot;.bar(::Float64)</span></span>
<span class="line"><span>  from bar(x) @ Main.var&quot;Main&quot; type_stability.md:79</span></span>
<span class="line"><span>Arguments</span></span>
<span class="line"><span>  #self#::Core.Const(Main.var&quot;Main&quot;.bar)</span></span>
<span class="line"><span>  x::Float64</span></span>
<span class="line"><span>Locals</span></span>
<span class="line"><span>  @_3::UNION{NOTHING, TUPLE{INT64, INT64}}</span></span>
<span class="line"><span>  res::ANY</span></span>
<span class="line"><span>  i::Int64</span></span>
<span class="line"><span>Body::ANY</span></span>
<span class="line"><span>1 ─ %1  = Main.var&quot;Main&quot;.zero::Core.Const(zero)</span></span>
<span class="line"><span>│         (res = (%1)(x))</span></span>
<span class="line"><span>│   %3  = Main.var&quot;Main&quot;.:(:)::Core.Const(Colon())</span></span>
<span class="line"><span>│   %4  = (%3)(1, 1000)::Core.Const(1:1000)</span></span>
<span class="line"><span>│         (@_3 = Base.iterate(%4))</span></span>
<span class="line"><span>│   %6  = @_3::Core.Const((1, 1))</span></span>
<span class="line"><span>│   %7  = (%6 === nothing)::Core.Const(false)</span></span>
<span class="line"><span>│   %8  = Base.not_int(%7)::Core.Const(true)</span></span>
<span class="line"><span>└──       goto #4 if not %8</span></span>
<span class="line"><span>2 ┄ %10 = @_3::Tuple{Int64, Int64}</span></span>
<span class="line"><span>│         (i = Core.getfield(%10, 1))</span></span>
<span class="line"><span>│   %12 = Core.getfield(%10, 2)::Int64</span></span>
<span class="line"><span>│   %13 = Main.var&quot;Main&quot;.:+::Core.Const(+)</span></span>
<span class="line"><span>│   %14 = res::ANY</span></span>
<span class="line"><span>│   %15 = Main.var&quot;Main&quot;.:*::Core.Const(*)</span></span>
<span class="line"><span>│   %16 = (%15)(Main.var&quot;Main&quot;.y, x)::ANY</span></span>
<span class="line"><span>│         (res = (%13)(%14, %16))</span></span>
<span class="line"><span>│         (@_3 = Base.iterate(%4, %12))</span></span>
<span class="line"><span>│   %19 = @_3::UNION{NOTHING, TUPLE{INT64, INT64}}</span></span>
<span class="line"><span>│   %20 = (%19 === nothing)::Bool</span></span>
<span class="line"><span>│   %21 = Base.not_int(%20)::Bool</span></span>
<span class="line"><span>└──       goto #4 if not %21</span></span>
<span class="line"><span>3 ─       goto #2</span></span>
<span class="line"><span>4 ┄ %24 = res::ANY</span></span>
<span class="line"><span>└──       return %24</span></span></code></pre></div><p>While in the last example of the <code>foo</code> function we got a weak form of type instability, returning a <code>Union{Int, Float64}</code>, in this case the return type of <code>bar</code> is <code>Any</code>, meaning that the compiler doesn&#39;t know anything about the return type. Thus, this function has nothing different from a dynamically typed language like Python. We can benchmark the performance of <code>bar</code> using the <a href="https://github.com/JuliaCI/BenchmarkTools.jl" target="_blank" rel="noreferrer">BenchmarkTools.jl</a> package:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BenchmarkTools</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@benchmark</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BenchmarkTools.Trial: 10000 samples with 1 evaluation per sample.</span></span>
<span class="line"><span> Range (min … max):  42.108 μs …  46.963 ms  ┊ GC (min … max): 0.00% … 99.76%</span></span>
<span class="line"><span> Time  (median):     61.465 μs               ┊ GC (median):    0.00%</span></span>
<span class="line"><span> Time  (mean ± σ):   62.531 μs ± 469.318 μs  ┊ GC (mean ± σ):  7.49% ±  1.00%</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  ▄█▇▄▁    ▁▁    ▄▇█▇▆▆▄  ▁▂▁▁▁                                ▂</span></span>
<span class="line"><span>  █████▆▄▃▄██▇▇▆▄████████▇██████▇▅▅▄▄▅▄▂▄▄▃▄▃▂▂▅▃▂▄▄▅▅▆▅▅▆▅▆▄▄ █</span></span>
<span class="line"><span>  42.1 μs       Histogram: log(frequency) by time       111 μs &lt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span> Memory estimate: 46.88 KiB, allocs estimate: 3000.</span></span></code></pre></div><p>Here we see a lot of memory allocations and low performances in general. To fix this, we can declare a <code>const</code> (constant) variable instead:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> z </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.4</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> zero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># this returns the zero of the same type of x</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> z </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@benchmark</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BenchmarkTools.Trial: 10000 samples with 57 evaluations per sample.</span></span>
<span class="line"><span> Range (min … max):  868.807 ns …  1.482 μs  ┊ GC (min … max): 0.00% … 0.00%</span></span>
<span class="line"><span> Time  (median):     869.684 ns              ┊ GC (median):    0.00%</span></span>
<span class="line"><span> Time  (mean ± σ):   877.082 ns ± 31.771 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  █     ▁                                                ▁▁▁   ▁</span></span>
<span class="line"><span>  █▅▅▅▅▅█▄▅▄▄▄▆▇▆▇▆▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▅██████ █</span></span>
<span class="line"><span>  869 ns        Histogram: log(frequency) by time         1 μs &lt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span> Memory estimate: 0 bytes, allocs estimate: 0.</span></span></code></pre></div><p>And we can see that the performance has improved significantly. Hence, we highly recommend using global variables as <code>const</code>, but only when truly necessary. This choice is problem-dependent, but in the case of <code>QuantumToolbox.jl</code>, this can be applied for example in the case of defining the Hilbert space dimensions, static parameters, or the system operators.</p><p>Although it is always a good practice to avoid such kind of type instabilities, in the actual implementation of <code>QuantumToolbox.jl</code> (where we mainly deal with linear algebra operations), the compiler may perform only a few runtime dispatches, and the performance penalty may be negligible compared to the heavy linear algebra operations.</p><h2 id="Vectors-vs-Tuples-vs-StaticArrays" tabindex="-1">Vectors vs Tuples vs StaticArrays <a class="header-anchor" href="#Vectors-vs-Tuples-vs-StaticArrays" aria-label="Permalink to &quot;Vectors vs Tuples vs StaticArrays {#Vectors-vs-Tuples-vs-StaticArrays}&quot;">​</a></h2><p>Julia has many ways to represent arrays or lists of general objects. The most common are <code>Vector</code>s and <code>Tuple</code>s. The former is a dynamic array that can change its size at runtime, while the latter is a fixed-size array that is immutable, and where the type of each element is already known at compile time. For example:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">v1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Vector of Int64</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">v2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.0im</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4.0im</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Vector of ComplexF64</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">v3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ciao&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Vector of Any</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Tuple of {Int64, Int64, Int64}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.0im</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4.0im</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Tuple of {ComplexF64, ComplexF64}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ciao&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Tuple of {Int64, String, Float64}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v1)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v2)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v3)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t1)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t2)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t3)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typeof(v1) = Vector{Int64}</span></span>
<span class="line"><span>typeof(v2) = Vector{ComplexF64}</span></span>
<span class="line"><span>typeof(v3) = Vector{Any}</span></span>
<span class="line"><span>typeof(t1) = Tuple{Int64, Int64, Int64}</span></span>
<span class="line"><span>typeof(t2) = Tuple{ComplexF64, ComplexF64}</span></span>
<span class="line"><span>typeof(t3) = Tuple{Int64, String, Float64}</span></span></code></pre></div><p>Thus, we highly recommend using <code>Vector</code> only when we are sure that it contains elements of the same type, and only when we don&#39;t need to know its size at compile time. On the other hand, <code>Tuple</code>s are less flexible but more efficient in terms of performance. A third option is to use the <code>SVector</code> type from the <a href="https://github.com/JuliaArrays/StaticArrays.jl" target="_blank" rel="noreferrer">StaticArrays.jl</a> package. This is similar to <code>Vector</code>, where the elements should have the same type, but it is fixed-size and immutable. One may ask when it is necessary to know the array size at compile time. A practical example is the case of <a href="/QuantumToolbox.jl/v0.30.1/resources/api#QuantumToolbox.ptrace"><code>ptrace</code></a>, where it internally reshapes the quantum state into a tensor whose dimensions depend on the number of subsystems. We will see this in more detail in the next section.</p><h2 id="The-QuantumObject-internal-structure" tabindex="-1">The <code>QuantumObject</code> internal structure <a class="header-anchor" href="#The-QuantumObject-internal-structure" aria-label="Permalink to &quot;The \`QuantumObject\` internal structure {#The-QuantumObject-internal-structure}&quot;">​</a></h2>`,37)),a("p",null,[s[2]||(s[2]=n("Before making a practical example, let's see the internal structure of the ")),s[3]||(s[3]=a("a",{href:"/QuantumToolbox.jl/v0.30.1/resources/api#QuantumToolbox.QuantumObject"},[a("code",null,"QuantumObject")],-1)),s[4]||(s[4]=n(" type. As an example, we consider the case of three qubits, and we study the internal structure of the ")),a("mjx-container",h,[(p(),e("svg",o,s[0]||(s[0]=[i('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(285.5,16) translate(-250 0)"><path data-c="5E" d="M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z" style="stroke-width:3;"></path></g></g></g><g data-mml-node="TeXAtom" transform="translate(604,530.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width:3;"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width:3;"></path></g></g><g data-mml-node="mi" transform="translate(604,-138.9) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z" style="stroke-width:3;"></path></g></g></g></g>',1)]))),s[1]||(s[1]=a("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msubsup",null,[a("mrow",{"data-mjx-texclass":"ORD"},[a("mover",null,[a("mi",null,"σ"),a("mo",{stretchy:"false"},"^")])]),a("mi",null,"x"),a("mrow",{"data-mjx-texclass":"ORD"},[a("mo",{stretchy:"false"},"("),a("mn",null,"2"),a("mo",{stretchy:"false"},")")])])])],-1))]),s[5]||(s[5]=n(" operator:"))]),s[19]||(s[19]=i(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">σx_2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qeye</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sigmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qeye</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>Quantum Object:   type=Operator   dims=[2, 2, 2]   size=(8, 8)   ishermitian=true</span></span>
<span class="line"><span>8×8 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:</span></span>
<span class="line"><span>     ⋅          ⋅      1.0+0.0im  …      ⋅          ⋅          ⋅    </span></span>
<span class="line"><span>     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅    </span></span>
<span class="line"><span> 1.0+0.0im      ⋅          ⋅             ⋅          ⋅          ⋅    </span></span>
<span class="line"><span>     ⋅      1.0+0.0im      ⋅             ⋅          ⋅          ⋅    </span></span>
<span class="line"><span>     ⋅          ⋅          ⋅             ⋅      1.0+0.0im      ⋅    </span></span>
<span class="line"><span>     ⋅          ⋅          ⋅      …      ⋅          ⋅      1.0+0.0im</span></span>
<span class="line"><span>     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅    </span></span>
<span class="line"><span>     ⋅          ⋅          ⋅         1.0+0.0im      ⋅          ⋅</span></span></code></pre></div><p>and its type is</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj_type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(σx_2)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>QuantumObject{OperatorQuantumObject, Dimensions{3, Tuple{Space, Space, Space}}, SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}</span></span></code></pre></div><p>This is exactly what the Julia compiler sees: it is a <a href="/QuantumToolbox.jl/v0.30.1/resources/api#QuantumToolbox.QuantumObject"><code>QuantumObject</code></a>, composed by a field of type <code>SparseMatrixCSC{ComplexF64, Int64}</code> (i.e., the 8x8 matrix containing the Pauli matrix, tensored with the identity matrices of the other two qubits). Then, we can also see that it is a <a href="/QuantumToolbox.jl/v0.30.1/resources/api#QuantumToolbox.OperatorQuantumObject"><code>OperatorQuantumObject</code></a>, with <code>3</code> subsystems in total. Hence, just looking at the type of the object, the compiler has all the information it needs to generate a specialized version of the functions.</p><p>Let&#39;s see more in the details all the internal fields of the <a href="/QuantumToolbox.jl/v0.30.1/resources/api#QuantumToolbox.QuantumObject"><code>QuantumObject</code></a> type:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fieldnames</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj_type)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(:data, :type, :dimensions)</span></span></code></pre></div><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">σx_2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>8×8 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:</span></span>
<span class="line"><span>     ⋅          ⋅      1.0+0.0im  …      ⋅          ⋅          ⋅    </span></span>
<span class="line"><span>     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅    </span></span>
<span class="line"><span> 1.0+0.0im      ⋅          ⋅             ⋅          ⋅          ⋅    </span></span>
<span class="line"><span>     ⋅      1.0+0.0im      ⋅             ⋅          ⋅          ⋅    </span></span>
<span class="line"><span>     ⋅          ⋅          ⋅             ⋅      1.0+0.0im      ⋅    </span></span>
<span class="line"><span>     ⋅          ⋅          ⋅      …      ⋅          ⋅      1.0+0.0im</span></span>
<span class="line"><span>     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅    </span></span>
<span class="line"><span>     ⋅          ⋅          ⋅         1.0+0.0im      ⋅          ⋅</span></span></code></pre></div><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">σx_2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">type</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Operator</span></span></code></pre></div><p><a href="/QuantumToolbox.jl/v0.30.1/resources/api#QuantumToolbox.Operator"><code>Operator</code></a> is a synonym for <a href="/QuantumToolbox.jl/v0.30.1/resources/api#QuantumToolbox.OperatorQuantumObject"><code>OperatorQuantumObject</code></a>.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">σx_2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dims</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>3-element StaticArraysCore.SVector{3, Int64} with indices SOneTo(3):</span></span>
<span class="line"><span> 2</span></span>
<span class="line"><span> 2</span></span>
<span class="line"><span> 2</span></span></code></pre></div><p>The <code>dims</code> field contains the dimensions of the subsystems (in this case, three subsystems with dimension <code>2</code> each). We can see that the type of <code>dims</code> is <code>SVector</code> instead of <code>Vector</code>. As we mentioned before, this is very useful in functions like <a href="/QuantumToolbox.jl/v0.30.1/resources/api#QuantumToolbox.ptrace"><code>ptrace</code></a>. Let&#39;s do a simple example of reshaping an operator internally generated from some <code>dims</code> input:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reshape_operator_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dims)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Qobj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">randn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dims), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dims)), type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Operator, dims</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dims)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    op_dims </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> op</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dims</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    op_data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> op</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> reshape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op_data, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vcat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op_dims, op_dims)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reshape_operator_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Array{Float64, 6}</span></span></code></pre></div><p>Which returns a tensor of size <code>2x2x2x2x2x2</code>. Let&#39;s check the <code>@code_warntype</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@code_warntype</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> reshape_operator_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MethodInstance for Main.var&quot;Main&quot;.reshape_operator_data(::Vector{Int64})</span></span>
<span class="line"><span>  from reshape_operator_data(dims) @ Main.var&quot;Main&quot; type_stability.md:186</span></span>
<span class="line"><span>Arguments</span></span>
<span class="line"><span>  #self#::Core.Const(Main.var&quot;Main&quot;.reshape_operator_data)</span></span>
<span class="line"><span>  dims::Vector{Int64}</span></span>
<span class="line"><span>Locals</span></span>
<span class="line"><span>  op_data::Matrix{Float64}</span></span>
<span class="line"><span>  op_dims::ANY</span></span>
<span class="line"><span>  op::QUANTUMOBJECT{OPERATORQUANTUMOBJECT, DIMENSIONS{_A, NTUPLE{N, SPACE}}, MATRIX{FLOAT64}} WHERE {_A, N}</span></span>
<span class="line"><span>Body::ANY</span></span>
<span class="line"><span>1 ─ %1  = Main.var&quot;Main&quot;.randn::Core.Const(randn)</span></span>
<span class="line"><span>│   %2  = Main.var&quot;Main&quot;.prod::Core.Const(prod)</span></span>
<span class="line"><span>│   %3  = (%2)(dims)::Int64</span></span>
<span class="line"><span>│   %4  = Main.var&quot;Main&quot;.prod::Core.Const(prod)</span></span>
<span class="line"><span>│   %5  = (%4)(dims)::Int64</span></span>
<span class="line"><span>│   %6  = (%1)(%3, %5)::Matrix{Float64}</span></span>
<span class="line"><span>│   %7  = (:type, :dims)::Core.Const((:type, :dims))</span></span>
<span class="line"><span>│   %8  = Core.apply_type(Core.NamedTuple, %7)::Core.Const(NamedTuple{(:type, :dims)})</span></span>
<span class="line"><span>│   %9  = Main.var&quot;Main&quot;.Operator::Core.Const(Operator)</span></span>
<span class="line"><span>│   %10 = Core.tuple(%9, dims)::Tuple{OperatorQuantumObject, Vector{Int64}}</span></span>
<span class="line"><span>│   %11 = (%8)(%10)::@NamedTuple{type::OperatorQuantumObject, dims::Vector{Int64}}</span></span>
<span class="line"><span>│   %12 = Main.var&quot;Main&quot;.Qobj::Core.Const(QuantumObject)</span></span>
<span class="line"><span>│         (op = Core.kwcall(%11, %12, %6))</span></span>
<span class="line"><span>│   %14 = op::QUANTUMOBJECT{OPERATORQUANTUMOBJECT, DIMENSIONS{_A, NTUPLE{N, SPACE}}, MATRIX{FLOAT64}} WHERE {_A, N}</span></span>
<span class="line"><span>│         (op_dims = Base.getproperty(%14, :dims))</span></span>
<span class="line"><span>│   %16 = op::QUANTUMOBJECT{OPERATORQUANTUMOBJECT, DIMENSIONS{_A, NTUPLE{N, SPACE}}, MATRIX{FLOAT64}} WHERE {_A, N}</span></span>
<span class="line"><span>│         (op_data = Base.getproperty(%16, :data))</span></span>
<span class="line"><span>│   %18 = Main.var&quot;Main&quot;.reshape::Core.Const(reshape)</span></span>
<span class="line"><span>│   %19 = op_data::Matrix{Float64}</span></span>
<span class="line"><span>│   %20 = Core.tuple(%19)::Tuple{Matrix{Float64}}</span></span>
<span class="line"><span>│   %21 = Main.var&quot;Main&quot;.vcat::Core.Const(vcat)</span></span>
<span class="line"><span>│   %22 = op_dims::ANY</span></span>
<span class="line"><span>│   %23 = op_dims::ANY</span></span>
<span class="line"><span>│   %24 = (%21)(%22, %23)::ANY</span></span>
<span class="line"><span>│   %25 = Core._apply_iterate(Base.iterate, %18, %20, %24)::ANY</span></span>
<span class="line"><span>└──       return %25</span></span></code></pre></div><p>We got a <code>Any</code> type, because the compiler doesn&#39;t know the size of the <code>dims</code> vector. We can fix this by using a <code>Tuple</code> (or <code>SVector</code> from <a href="https://github.com/JuliaArrays/StaticArrays.jl" target="_blank" rel="noreferrer">StaticArrays.jl</a>):</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reshape_operator_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)))</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Array{Float64, 6}</span></span></code></pre></div><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@code_warntype</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> reshape_operator_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MethodInstance for Main.var&quot;Main&quot;.reshape_operator_data(::Tuple{Int64, Int64, Int64})</span></span>
<span class="line"><span>  from reshape_operator_data(dims) @ Main.var&quot;Main&quot; type_stability.md:186</span></span>
<span class="line"><span>Arguments</span></span>
<span class="line"><span>  #self#::Core.Const(Main.var&quot;Main&quot;.reshape_operator_data)</span></span>
<span class="line"><span>  dims::Tuple{Int64, Int64, Int64}</span></span>
<span class="line"><span>Locals</span></span>
<span class="line"><span>  op_data::Matrix{Float64}</span></span>
<span class="line"><span>  op_dims::StaticArraysCore.SVector{3, Int64}</span></span>
<span class="line"><span>  op::QuantumObject{OperatorQuantumObject, Dimensions{3, Tuple{Space, Space, Space}}, Matrix{Float64}}</span></span>
<span class="line"><span>Body::Array{Float64, 6}</span></span>
<span class="line"><span>1 ─ %1  = Main.var&quot;Main&quot;.randn::Core.Const(randn)</span></span>
<span class="line"><span>│   %2  = Main.var&quot;Main&quot;.prod::Core.Const(prod)</span></span>
<span class="line"><span>│   %3  = (%2)(dims)::Int64</span></span>
<span class="line"><span>│   %4  = Main.var&quot;Main&quot;.prod::Core.Const(prod)</span></span>
<span class="line"><span>│   %5  = (%4)(dims)::Int64</span></span>
<span class="line"><span>│   %6  = (%1)(%3, %5)::Matrix{Float64}</span></span>
<span class="line"><span>│   %7  = (:type, :dims)::Core.Const((:type, :dims))</span></span>
<span class="line"><span>│   %8  = Core.apply_type(Core.NamedTuple, %7)::Core.Const(NamedTuple{(:type, :dims)})</span></span>
<span class="line"><span>│   %9  = Main.var&quot;Main&quot;.Operator::Core.Const(Operator)</span></span>
<span class="line"><span>│   %10 = Core.tuple(%9, dims)::Tuple{OperatorQuantumObject, Tuple{Int64, Int64, Int64}}</span></span>
<span class="line"><span>│   %11 = (%8)(%10)::@NamedTuple{type::OperatorQuantumObject, dims::Tuple{Int64, Int64, Int64}}</span></span>
<span class="line"><span>│   %12 = Main.var&quot;Main&quot;.Qobj::Core.Const(QuantumObject)</span></span>
<span class="line"><span>│         (op = Core.kwcall(%11, %12, %6))</span></span>
<span class="line"><span>│   %14 = op::QuantumObject{OperatorQuantumObject, Dimensions{3, Tuple{Space, Space, Space}}, Matrix{Float64}}</span></span>
<span class="line"><span>│         (op_dims = Base.getproperty(%14, :dims))</span></span>
<span class="line"><span>│   %16 = op::QuantumObject{OperatorQuantumObject, Dimensions{3, Tuple{Space, Space, Space}}, Matrix{Float64}}</span></span>
<span class="line"><span>│         (op_data = Base.getproperty(%16, :data))</span></span>
<span class="line"><span>│   %18 = Main.var&quot;Main&quot;.reshape::Core.Const(reshape)</span></span>
<span class="line"><span>│   %19 = op_data::Matrix{Float64}</span></span>
<span class="line"><span>│   %20 = Core.tuple(%19)::Tuple{Matrix{Float64}}</span></span>
<span class="line"><span>│   %21 = Main.var&quot;Main&quot;.vcat::Core.Const(vcat)</span></span>
<span class="line"><span>│   %22 = op_dims::StaticArraysCore.SVector{3, Int64}</span></span>
<span class="line"><span>│   %23 = op_dims::StaticArraysCore.SVector{3, Int64}</span></span>
<span class="line"><span>│   %24 = (%21)(%22, %23)::StaticArraysCore.SVector{6, Int64}</span></span>
<span class="line"><span>│   %25 = Core._apply_iterate(Base.iterate, %18, %20, %24)::Array{Float64, 6}</span></span>
<span class="line"><span>└──       return %25</span></span></code></pre></div><p>Finally, let&#39;s look at the benchmarks</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@benchmark</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> reshape_operator_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BenchmarkTools.Trial: 10000 samples with 10 evaluations per sample.</span></span>
<span class="line"><span> Range (min … max):  1.674 μs …   9.473 μs  ┊ GC (min … max): 0.00% … 0.00%</span></span>
<span class="line"><span> Time  (median):     2.079 μs               ┊ GC (median):    0.00%</span></span>
<span class="line"><span> Time  (mean ± σ):   2.133 μs ± 362.802 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        ▂█▃  ▂▅▂                                               </span></span>
<span class="line"><span>  ▁▂▂▂▁▂███▆▄███▅▄▄▄▃▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂</span></span>
<span class="line"><span>  1.67 μs         Histogram: frequency by time        3.72 μs &lt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span> Memory estimate: 1.41 KiB, allocs estimate: 29.</span></span></code></pre></div><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@benchmark</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> reshape_operator_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)))</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BenchmarkTools.Trial: 10000 samples with 606 evaluations per sample.</span></span>
<span class="line"><span> Range (min … max):  203.546 ns … 85.843 μs  ┊ GC (min … max):  0.00% … 99.68%</span></span>
<span class="line"><span> Time  (median):     216.558 ns              ┊ GC (median):     0.00%</span></span>
<span class="line"><span> Time  (mean ± σ):   340.209 ns ±  1.283 μs  ┊ GC (mean ± σ):  16.18% ±  8.73%</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  ▆█                                                            </span></span>
<span class="line"><span>  ██▅▅▃▃▂▂▂▂▂▂▂▂▂▂▂▂▁▂▁▁▁▁▁▁▁▁▂▂▂▂▃▆▆▄▃▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▁▁▁▂▂▂ ▂</span></span>
<span class="line"><span>  204 ns          Histogram: frequency by time          657 ns &lt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span> Memory estimate: 672 bytes, allocs estimate: 3.</span></span></code></pre></div><p>Which is an innocuous but huge difference in terms of performance. Hence, we highly recommend using <code>Tuple</code> or <code>SVector</code> from <a href="https://github.com/JuliaArrays/StaticArrays.jl" target="_blank" rel="noreferrer">StaticArrays.jl</a> when defining the dimensions of a user-defined <a href="/QuantumToolbox.jl/v0.30.1/resources/api#QuantumToolbox.QuantumObject"><code>QuantumObject</code></a>.</p><h2 id="The-use-of-Val-in-some-QuantumToolbox.jl-functions" tabindex="-1">The use of <code>Val</code> in some <code>QuantumToolbox.jl</code> functions <a class="header-anchor" href="#The-use-of-Val-in-some-QuantumToolbox.jl-functions" aria-label="Permalink to &quot;The use of \`Val\` in some \`QuantumToolbox.jl\` functions {#The-use-of-Val-in-some-QuantumToolbox.jl-functions}&quot;">​</a></h2>`,34)),a("p",null,[s[8]||(s[8]=n("In some functions of ")),s[9]||(s[9]=a("code",null,"QuantumToolbox.jl",-1)),s[10]||(s[10]=n(", you may find the use of the ")),s[11]||(s[11]=a("a",{href:"https://docs.julialang.org/en/v1/base/base/#Base.Val",target:"_blank",rel:"noreferrer"},[a("code",null,"Val")],-1)),s[12]||(s[12]=n(" type in the arguments. This is a trick to pass a value at compile time, and it is very useful to avoid type instabilities. Let's make a very simple example, where we want to create a Fock state ")),a("mjx-container",r,[(p(),e("svg",k,s[6]||(s[6]=[i('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(690,0)"><path data-c="27E9" d="M55 732Q56 739 61 744T75 750Q85 750 92 740Q95 733 186 494T278 250T187 6T92 -240Q85 -250 75 -250Q67 -250 62 -245T55 -232Q55 -227 145 11Q236 248 236 250T145 489Q55 727 55 732Z" style="stroke-width:3;"></path></g></g></g>',1)]))),s[7]||(s[7]=a("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("mo",{"data-mjx-texclass":"ORD",stretchy:"false"},"|"),a("mi",null,"j"),a("mo",{fence:"false",stretchy:"false"},"⟩")])],-1))]),s[13]||(s[13]=n(" of a given dimension ")),s[14]||(s[14]=a("code",null,"N",-1)),s[15]||(s[15]=n(", and we give the possibility to create it as a sparse or dense vector. At first, we can write the function without using ")),s[16]||(s[16]=a("code",null,"Val",-1)),s[17]||(s[17]=n(":"))]),s[20]||(s[20]=i(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SparseArrays</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my_fock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; sparse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sparse</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sparsevec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0im</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], N)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> zeros</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ComplexF64, N)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        array[j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> QuantumObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array; type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Ket)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> my_fock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> my_fock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; sparse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>my_fock(2, 1) =</span></span>
<span class="line"><span>Quantum Object:   type=Ket   dims=[2]   size=(2,)</span></span>
<span class="line"><span>2-element Vector{ComplexF64}:</span></span>
<span class="line"><span> 0.0 + 0.0im</span></span>
<span class="line"><span> 1.0 + 0.0im</span></span>
<span class="line"><span>my_fock(2, 1; sparse = true) =</span></span>
<span class="line"><span>Quantum Object:   type=Ket   dims=[2]   size=(2,)</span></span>
<span class="line"><span>2-element SparseArrays.SparseVector{ComplexF64, Int64} with 1 stored entry:</span></span>
<span class="line"><span>  [2]  =  1.0+0.0im</span></span></code></pre></div><p>But it is immediately clear that the return type of this function is not clear, because it depends on the value of the <code>sparse</code> argument. We can check it using the <code>@code_warntype</code> macro:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@code_warntype</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> my_fock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MethodInstance for Main.var&quot;Main&quot;.my_fock(::Int64, ::Int64)</span></span>
<span class="line"><span>  from my_fock(N::Int64, j::Int64; sparse) @ Main.var&quot;Main&quot; type_stability.md:231</span></span>
<span class="line"><span>Arguments</span></span>
<span class="line"><span>  #self#::Core.Const(Main.var&quot;Main&quot;.my_fock)</span></span>
<span class="line"><span>  N::Int64</span></span>
<span class="line"><span>  j::Int64</span></span>
<span class="line"><span>Body::UNION{QUANTUMOBJECT{KETQUANTUMOBJECT, DIMENSIONS{1, TUPLE{SPACE}}, VECTOR{COMPLEXF64}}, QUANTUMOBJECT{KETQUANTUMOBJECT, DIMENSIONS{1, TUPLE{SPACE}}, SPARSEARRAYS.SPARSEVECTOR{COMPLEXF64, INT64}}}</span></span>
<span class="line"><span>1 ─ %1 = Main.var&quot;Main&quot;.:(var&quot;#my_fock#1&quot;)::Core.Const(Main.var&quot;Main&quot;.var&quot;#my_fock#1&quot;)</span></span>
<span class="line"><span>│   %2 = (%1)(false, #self#, N, j)::UNION{QUANTUMOBJECT{KETQUANTUMOBJECT, DIMENSIONS{1, TUPLE{SPACE}}, VECTOR{COMPLEXF64}}, QUANTUMOBJECT{KETQUANTUMOBJECT, DIMENSIONS{1, TUPLE{SPACE}}, SPARSEARRAYS.SPARSEVECTOR{COMPLEXF64, INT64}}}</span></span>
<span class="line"><span>└──      return %2</span></span></code></pre></div><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@code_warntype</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> my_fock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; sparse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MethodInstance for Core.kwcall(::@NamedTuple{sparse::Bool}, ::typeof(Main.var&quot;Main&quot;.my_fock), ::Int64, ::Int64)</span></span>
<span class="line"><span>  from kwcall(::NamedTuple, ::typeof(Main.var&quot;Main&quot;.my_fock), N::Int64, j::Int64) @ Main.var&quot;Main&quot; type_stability.md:231</span></span>
<span class="line"><span>Arguments</span></span>
<span class="line"><span>  #s5::Core.Const(Core.kwcall)</span></span>
<span class="line"><span>  @_2::@NamedTuple{sparse::Bool}</span></span>
<span class="line"><span>  @_3::Core.Const(Main.var&quot;Main&quot;.my_fock)</span></span>
<span class="line"><span>  N::Int64</span></span>
<span class="line"><span>  j::Int64</span></span>
<span class="line"><span>Locals</span></span>
<span class="line"><span>  sparse::Union{}</span></span>
<span class="line"><span>  @_7::Bool</span></span>
<span class="line"><span>Body::UNION{QUANTUMOBJECT{KETQUANTUMOBJECT, DIMENSIONS{1, TUPLE{SPACE}}, VECTOR{COMPLEXF64}}, QUANTUMOBJECT{KETQUANTUMOBJECT, DIMENSIONS{1, TUPLE{SPACE}}, SPARSEARRAYS.SPARSEVECTOR{COMPLEXF64, INT64}}}</span></span>
<span class="line"><span>1 ──       Core.NewvarNode(:(sparse))</span></span>
<span class="line"><span>│          Core.NewvarNode(:(@_7))</span></span>
<span class="line"><span>│    %3  = Core.isdefined(@_2, :sparse)::Core.Const(true)</span></span>
<span class="line"><span>└───       goto #6 if not %3</span></span>
<span class="line"><span>2 ── %5  = Core.getfield(@_2, :sparse)::Bool</span></span>
<span class="line"><span>│    %6  = Main.var&quot;Main&quot;.Bool::Core.Const(Bool)</span></span>
<span class="line"><span>│    %7  = (%5 isa %6)::Core.Const(true)</span></span>
<span class="line"><span>└───       goto #4 if not %7</span></span>
<span class="line"><span>3 ──       goto #5</span></span>
<span class="line"><span>4 ──       Core.Const(:(Main.var&quot;Main&quot;.Bool))</span></span>
<span class="line"><span>│          Core.Const(:(%new(Core.TypeError, Symbol(&quot;keyword argument&quot;), :sparse, %10, %5)))</span></span>
<span class="line"><span>└───       Core.Const(:(Core.throw(%11)))</span></span>
<span class="line"><span>5 ┄─       (@_7 = %5)</span></span>
<span class="line"><span>└───       goto #7</span></span>
<span class="line"><span>6 ──       Core.Const(:(@_7 = false))</span></span>
<span class="line"><span>7 ┄─ %16 = @_7::Bool</span></span>
<span class="line"><span>│    %17 = Base.keys(@_2)::Core.Const((:sparse,))</span></span>
<span class="line"><span>│    %18 = (:sparse,)::Core.Const((:sparse,))</span></span>
<span class="line"><span>│    %19 = Base.diff_names(%17, %18)::Core.Const(())</span></span>
<span class="line"><span>│    %20 = Base.isempty(%19)::Core.Const(true)</span></span>
<span class="line"><span>└───       goto #9 if not %20</span></span>
<span class="line"><span>8 ──       goto #10</span></span>
<span class="line"><span>9 ──       Core.Const(:(Base.kwerr(@_2, @_3, N, j)))</span></span>
<span class="line"><span>10 ┄ %24 = Main.var&quot;Main&quot;.:(var&quot;#my_fock#1&quot;)::Core.Const(Main.var&quot;Main&quot;.var&quot;#my_fock#1&quot;)</span></span>
<span class="line"><span>│    %25 = (%24)(%16, @_3, N, j)::UNION{QUANTUMOBJECT{KETQUANTUMOBJECT, DIMENSIONS{1, TUPLE{SPACE}}, VECTOR{COMPLEXF64}}, QUANTUMOBJECT{KETQUANTUMOBJECT, DIMENSIONS{1, TUPLE{SPACE}}, SPARSEARRAYS.SPARSEVECTOR{COMPLEXF64, INT64}}}</span></span>
<span class="line"><span>└───       return %25</span></span></code></pre></div><p>We can fix this by using the <code>Val</code> type, where we enable the multiple dispatch of the function:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{N}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> N </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> N</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my_fock_good</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; sparse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> getVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sparse)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> zeros</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ComplexF64, N)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        array[j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sparsevec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0im</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], N)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> QuantumObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array; type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Ket)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> my_fock_good</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@show</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> my_fock_good</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; sparse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>my_fock_good(2, 1) =</span></span>
<span class="line"><span>Quantum Object:   type=Ket   dims=[2]   size=(2,)</span></span>
<span class="line"><span>2-element SparseArrays.SparseVector{ComplexF64, Int64} with 1 stored entry:</span></span>
<span class="line"><span>  [2]  =  1.0+0.0im</span></span>
<span class="line"><span>my_fock_good(2, 1; sparse = Val(true)) =</span></span>
<span class="line"><span>Quantum Object:   type=Ket   dims=[2]   size=(2,)</span></span>
<span class="line"><span>2-element Vector{ComplexF64}:</span></span>
<span class="line"><span> 0.0 + 0.0im</span></span>
<span class="line"><span> 1.0 + 0.0im</span></span></code></pre></div><p>And now the return type of the function is clear:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@code_warntype</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> my_fock_good</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MethodInstance for Main.var&quot;Main&quot;.my_fock_good(::Int64, ::Int64)</span></span>
<span class="line"><span>  from my_fock_good(N::Int64, j::Int64; sparse) @ Main.var&quot;Main&quot; type_stability.md:259</span></span>
<span class="line"><span>Arguments</span></span>
<span class="line"><span>  #self#::Core.Const(Main.var&quot;Main&quot;.my_fock_good)</span></span>
<span class="line"><span>  N::Int64</span></span>
<span class="line"><span>  j::Int64</span></span>
<span class="line"><span>Body::QuantumObject{KetQuantumObject, Dimensions{1, Tuple{Space}}, SparseArrays.SparseVector{ComplexF64, Int64}}</span></span>
<span class="line"><span>1 ─ %1 = Main.var&quot;Main&quot;.:(var&quot;#my_fock_good#2&quot;)::Core.Const(Main.var&quot;Main&quot;.var&quot;#my_fock_good#2&quot;)</span></span>
<span class="line"><span>│   %2 = Main.var&quot;Main&quot;.Val(false)::Core.Const(Val{false}())</span></span>
<span class="line"><span>│   %3 = (%1)(%2, #self#, N, j)::QuantumObject{KetQuantumObject, Dimensions{1, Tuple{Space}}, SparseArrays.SparseVector{ComplexF64, Int64}}</span></span>
<span class="line"><span>└──      return %3</span></span></code></pre></div><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@code_warntype</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> my_fock_good</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; sparse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MethodInstance for Core.kwcall(::@NamedTuple{sparse::Val{true}}, ::typeof(Main.var&quot;Main&quot;.my_fock_good), ::Int64, ::Int64)</span></span>
<span class="line"><span>  from kwcall(::NamedTuple, ::typeof(Main.var&quot;Main&quot;.my_fock_good), N::Int64, j::Int64) @ Main.var&quot;Main&quot; type_stability.md:259</span></span>
<span class="line"><span>Arguments</span></span>
<span class="line"><span>  #s5::Core.Const(Core.kwcall)</span></span>
<span class="line"><span>  @_2::Core.Const((sparse = Val{true}(),))</span></span>
<span class="line"><span>  @_3::Core.Const(Main.var&quot;Main&quot;.my_fock_good)</span></span>
<span class="line"><span>  N::Int64</span></span>
<span class="line"><span>  j::Int64</span></span>
<span class="line"><span>Locals</span></span>
<span class="line"><span>  sparse::Union{}</span></span>
<span class="line"><span>  @_7::Val{true}</span></span>
<span class="line"><span>Body::QuantumObject{KetQuantumObject, Dimensions{1, Tuple{Space}}, Vector{ComplexF64}}</span></span>
<span class="line"><span>1 ──       Core.NewvarNode(:(sparse))</span></span>
<span class="line"><span>│          Core.NewvarNode(:(@_7))</span></span>
<span class="line"><span>│    %3  = Core.isdefined(@_2, :sparse)::Core.Const(true)</span></span>
<span class="line"><span>└───       goto #6 if not %3</span></span>
<span class="line"><span>2 ── %5  = Core.getfield(@_2, :sparse)::Core.Const(Val{true}())</span></span>
<span class="line"><span>│    %6  = (%5 isa Main.var&quot;Main&quot;.Val)::Core.Const(true)</span></span>
<span class="line"><span>└───       goto #4 if not %6</span></span>
<span class="line"><span>3 ──       goto #5</span></span>
<span class="line"><span>4 ──       Core.Const(:(%new(Core.TypeError, Symbol(&quot;keyword argument&quot;), :sparse, Main.var&quot;Main&quot;.Val, %5)))</span></span>
<span class="line"><span>└───       Core.Const(:(Core.throw(%9)))</span></span>
<span class="line"><span>5 ┄─       (@_7 = %5)</span></span>
<span class="line"><span>└───       goto #7</span></span>
<span class="line"><span>6 ──       Core.Const(:(@_7 = Main.var&quot;Main&quot;.Val(false)))</span></span>
<span class="line"><span>7 ┄─ %14 = @_7::Core.Const(Val{true}())</span></span>
<span class="line"><span>│    %15 = Base.keys(@_2)::Core.Const((:sparse,))</span></span>
<span class="line"><span>│    %16 = (:sparse,)::Core.Const((:sparse,))</span></span>
<span class="line"><span>│    %17 = Base.diff_names(%15, %16)::Core.Const(())</span></span>
<span class="line"><span>│    %18 = Base.isempty(%17)::Core.Const(true)</span></span>
<span class="line"><span>└───       goto #9 if not %18</span></span>
<span class="line"><span>8 ──       goto #10</span></span>
<span class="line"><span>9 ──       Core.Const(:(Base.kwerr(@_2, @_3, N, j)))</span></span>
<span class="line"><span>10 ┄ %22 = Main.var&quot;Main&quot;.:(var&quot;#my_fock_good#2&quot;)::Core.Const(Main.var&quot;Main&quot;.var&quot;#my_fock_good#2&quot;)</span></span>
<span class="line"><span>│    %23 = (%22)(%14, @_3, N, j)::QuantumObject{KetQuantumObject, Dimensions{1, Tuple{Space}}, Vector{ComplexF64}}</span></span>
<span class="line"><span>└───       return %23</span></span></code></pre></div><p>This is exactly how the current <a href="/QuantumToolbox.jl/v0.30.1/resources/api#QuantumToolbox.fock"><code>fock</code></a> function is implemented in <code>QuantumToolbox.jl</code>. There are many other functions that support this feature, and we highly recommend using it when necessary.</p><h2 id="conclusions" tabindex="-1">Conclusions <a class="header-anchor" href="#conclusions" aria-label="Permalink to &quot;Conclusions&quot;">​</a></h2><p>In this page, we have seen the importance of type stability in Julia, and how to write efficient code in the context of <code>QuantumToolbox.jl</code>. We have seen that the internal structure of the <a href="/QuantumToolbox.jl/v0.30.1/resources/api#QuantumToolbox.QuantumObject"><code>QuantumObject</code></a> type is already optimized for the compiler, and we have seen some practical examples of how to write efficient code. We have seen that the use of <code>Vector</code> should be avoided when the elements don&#39;t have the same type, and that the use of <code>Tuple</code> or <code>SVector</code> is highly recommended when the size of the array is known at compile time. Finally, we have seen the use of <code>Val</code> to pass values at compile time, to avoid type instabilities in some functions. \`\`\`</p>`,18))])}const F=t(l,[["render",d]]);export{C as __pageData,F as default};
