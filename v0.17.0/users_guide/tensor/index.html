<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tensor Products and Partial Traces · QuantumToolbox.jl</title><meta name="title" content="Tensor Products and Partial Traces · QuantumToolbox.jl"/><meta property="og:title" content="Tensor Products and Partial Traces · QuantumToolbox.jl"/><meta property="twitter:title" content="Tensor Products and Partial Traces · QuantumToolbox.jl"/><meta name="description" content="Documentation for QuantumToolbox.jl."/><meta property="og:description" content="Documentation for QuantumToolbox.jl."/><meta property="twitter:description" content="Documentation for QuantumToolbox.jl."/><meta property="og:url" content="https://qutip.github.io/QuantumToolbox.jl/users_guide/tensor/"/><meta property="twitter:url" content="https://qutip.github.io/QuantumToolbox.jl/users_guide/tensor/"/><link rel="canonical" href="https://qutip.github.io/QuantumToolbox.jl/users_guide/tensor/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="QuantumToolbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../qutip_differences/">Key differences from QuTiP</a></li><li><a class="tocitem" href="../../type_stability/">The Importance of Type-Stability</a></li></ul></li><li><span class="tocitem">Users Guide</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Basic Operations on Quantum Objects</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../QuantumObject/QuantumObject/">Quantum Objects (Qobj)</a></li><li><a class="tocitem" href="../QuantumObject/QuantumObject_functions/">Functions operating on Qobj</a></li></ul></li><li><a class="tocitem" href="../states_and_operators/">Manipulating States and Operators</a></li><li class="is-active"><a class="tocitem" href>Tensor Products and Partial Traces</a><ul class="internal"><li><a class="tocitem" href="#doc:Tensor-products"><span>Tensor products</span></a></li><li><a class="tocitem" href="#Example:-Constructing-composite-Hamiltonians"><span>Example: Constructing composite Hamiltonians</span></a></li><li><a class="tocitem" href="#doc:Partial-trace"><span>Partial trace</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Time Evolution and Dynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../time_evolution/intro/">Introduction</a></li><li><a class="tocitem" href="../time_evolution/solution/">Time Evolution Solutions</a></li><li><a class="tocitem" href="../time_evolution/sesolve/">Schrödinger Equation Solver</a></li><li><a class="tocitem" href="../time_evolution/mesolve/">Lindblad Master Equation Solver</a></li><li><a class="tocitem" href="../time_evolution/mcsolve/">Monte-Carlo Solver</a></li><li><a class="tocitem" href="../time_evolution/stochastic/">Stochastic Solver</a></li><li><a class="tocitem" href="../time_evolution/time_dependent/">Solving Problems with Time-dependent Hamiltonians</a></li></ul></li><li><a class="tocitem" href="../steadystate/">Solving for Steady-State Solutions</a></li><li><span class="tocitem">Symmetries</span></li><li><span class="tocitem">Two-time correlation functions</span></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Extensions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../extensions/cuda/">Extension for CUDA.jl</a></li></ul></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Time Evolution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/lowrank/">Low Rank Master Equation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Miscellaneous Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/logo/">Create QuantumToolbox.jl logo</a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Users Guide</a></li><li class="is-active"><a href>Tensor Products and Partial Traces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tensor Products and Partial Traces</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/qutip/QuantumToolbox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/qutip/QuantumToolbox.jl/blob/main/docs/src/users_guide/tensor.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="doc:Tensor-products-and-Partial-Traces"><a class="docs-heading-anchor" href="#doc:Tensor-products-and-Partial-Traces">Tensor Products and Partial Traces</a><a id="doc:Tensor-products-and-Partial-Traces-1"></a><a class="docs-heading-anchor-permalink" href="#doc:Tensor-products-and-Partial-Traces" title="Permalink"></a></h1><h2 id="doc:Tensor-products"><a class="docs-heading-anchor" href="#doc:Tensor-products">Tensor products</a><a id="doc:Tensor-products-1"></a><a class="docs-heading-anchor-permalink" href="#doc:Tensor-products" title="Permalink"></a></h2><p>To describe the states of multipartite quantum systems (such as two coupled qubits, a qubit coupled to an oscillator, etc.) we need to expand the Hilbert space by taking the tensor product of the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators.</p><p>In <code>QuantumToolbox</code>, the function <a href="../../api/#QuantumToolbox.tensor"><code>tensor</code></a> (or <a href="../../api/#Base.kron"><code>kron</code></a>) is used to accomplish this task. This function takes a collection of <a href="../../api/#QuantumToolbox.Ket"><code>Ket</code></a> or <a href="../../api/#QuantumToolbox.Operator"><code>Operator</code></a> as argument and returns a composite <a href="../../api/#QuantumToolbox.QuantumObject"><code>QuantumObject</code></a> for the combined Hilbert space. The function accepts an arbitrary number of <a href="../../api/#QuantumToolbox.QuantumObject"><code>QuantumObject</code></a> as argument. The <code>type</code> of returned <a href="../../api/#QuantumToolbox.QuantumObject"><code>QuantumObject</code></a> is the same as that of the input(s).</p><p>A collection of <a href="../../api/#QuantumToolbox.QuantumObject"><code>QuantumObject</code></a>:</p><pre><code class="language-julia hljs">tensor(sigmax(), sigmax(), sigmax())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2, 2, 2]   size=(8, 8)   ishermitian=true
8×8 SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅          ⋅      …      ⋅          ⋅      1.0+0.0im
     ⋅          ⋅          ⋅             ⋅      1.0+0.0im      ⋅    
     ⋅          ⋅          ⋅         1.0+0.0im      ⋅          ⋅    
     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅    
     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅    
     ⋅          ⋅      1.0+0.0im  …      ⋅          ⋅          ⋅    
     ⋅      1.0+0.0im      ⋅             ⋅          ⋅          ⋅    
 1.0+0.0im      ⋅          ⋅             ⋅          ⋅          ⋅    </code></pre><p>or a <code>Vector{QuantumObject}</code>:</p><pre><code class="language-julia hljs">op_list = fill(sigmax(), 3)
tensor(op_list)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2, 2, 2]   size=(8, 8)   ishermitian=true
8×8 SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅          ⋅      …      ⋅          ⋅      1.0+0.0im
     ⋅          ⋅          ⋅             ⋅      1.0+0.0im      ⋅    
     ⋅          ⋅          ⋅         1.0+0.0im      ⋅          ⋅    
     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅    
     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅    
     ⋅          ⋅      1.0+0.0im  …      ⋅          ⋅          ⋅    
     ⋅      1.0+0.0im      ⋅             ⋅          ⋅          ⋅    
 1.0+0.0im      ⋅          ⋅             ⋅          ⋅          ⋅    </code></pre><div class="admonition is-warning"><header class="admonition-header">Beware of type-stability!</header><div class="admonition-body"><p>Please note that <code>tensor(op_list)</code> or <code>kron(op_list)</code> with <code>op_list</code> is a <code>Vector</code> is type-instable and can hurt performance. It is recommended to use <code>tensor(op_list...)</code> or <code>kron(op_list...)</code> instead. See the Section <a href="../../type_stability/#doc:Type-Stability">The Importance of Type-Stability</a> for more details.</p></div></div><p>For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:</p><pre><code class="language-julia hljs">tensor(basis(2, 0), basis(2, 0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Ket   dims=[2, 2]   size=(4,)
4-element Vector{ComplexF64}:
 1.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im</code></pre><p>One can generalize to more qubits by adding more component state vectors in the argument list to the <a href="../../api/#QuantumToolbox.tensor"><code>tensor</code></a> (or <a href="../../api/#Base.kron"><code>kron</code></a>) function, as illustrated in the following example:</p><pre><code class="language-julia hljs">states = QuantumObject[
    normalize(basis(2, 0) + basis(2, 1)),
    normalize(basis(2, 0) + basis(2, 1)),
    basis(2, 0)
]
tensor(states...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Ket   dims=[2, 2, 2]   size=(8,)
8-element Vector{ComplexF64}:
 0.4999999999999999 + 0.0im
                0.0 + 0.0im
 0.4999999999999999 + 0.0im
                0.0 + 0.0im
 0.4999999999999999 + 0.0im
                0.0 + 0.0im
 0.4999999999999999 + 0.0im
                0.0 + 0.0im</code></pre><p>This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.</p><p>To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the <a href="../../api/#QuantumToolbox.tensor"><code>tensor</code></a> (or <a href="../../api/#Base.kron"><code>kron</code></a>) function. For example, to form the operator that represents the simultaneous action of the <span>$\hat{\sigma}_x$</span> operator on two qubits:</p><pre><code class="language-julia hljs">tensor(sigmax(), sigmax())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2, 2]   size=(4, 4)   ishermitian=true
4×4 SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
     ⋅          ⋅          ⋅      1.0+0.0im
     ⋅          ⋅      1.0+0.0im      ⋅    
     ⋅      1.0+0.0im      ⋅          ⋅    
 1.0+0.0im      ⋅          ⋅          ⋅    </code></pre><p>To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents <span>$\hat{\sigma}_z$</span> on the first qubit in a two-qubit system, while leaving the second qubit unaffected:</p><pre><code class="language-julia hljs">tensor(sigmaz(), qeye(2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2, 2]   size=(4, 4)   ishermitian=true
4×4 SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
 1.0+0.0im      ⋅           ⋅           ⋅    
     ⋅      1.0+0.0im       ⋅           ⋅    
     ⋅          ⋅      -1.0+0.0im       ⋅    
     ⋅          ⋅           ⋅      -1.0+0.0im</code></pre><h2 id="Example:-Constructing-composite-Hamiltonians"><a class="docs-heading-anchor" href="#Example:-Constructing-composite-Hamiltonians">Example: Constructing composite Hamiltonians</a><a id="Example:-Constructing-composite-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Constructing-composite-Hamiltonians" title="Permalink"></a></h2><p>The <a href="../../api/#QuantumToolbox.tensor"><code>tensor</code></a> (or <a href="../../api/#Base.kron"><code>kron</code></a>) function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples.</p><h3 id="Two-coupled-qubits"><a class="docs-heading-anchor" href="#Two-coupled-qubits">Two coupled qubits</a><a id="Two-coupled-qubits-1"></a><a class="docs-heading-anchor-permalink" href="#Two-coupled-qubits" title="Permalink"></a></h3><p>First, let’s consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a <span>$\hat{\sigma}_x \otimes \hat{\sigma}_x$</span> interaction with strength <span>$g = 0.05$</span> (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:</p><pre><code class="language-julia hljs">H = tensor(sigmaz(), qeye(2)) +
    tensor(qeye(2), sigmaz()) +
    0.05 * tensor(sigmax(), sigmax())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2, 2]   size=(4, 4)   ishermitian=true
4×4 SparseMatrixCSC{ComplexF64, Int64} with 6 stored entries:
  2.0+0.0im       ⋅           ⋅      0.05+0.0im
      ⋅           ⋅      0.05+0.0im       ⋅    
      ⋅      0.05+0.0im       ⋅           ⋅    
 0.05+0.0im       ⋅           ⋅      -2.0+0.0im</code></pre><h3 id="Three-coupled-qubits"><a class="docs-heading-anchor" href="#Three-coupled-qubits">Three coupled qubits</a><a id="Three-coupled-qubits-1"></a><a class="docs-heading-anchor-permalink" href="#Three-coupled-qubits" title="Permalink"></a></h3><p>The two-qubit example is easily generalized to three coupled qubits:</p><pre><code class="language-julia hljs">H = tensor(sigmaz(), qeye(2), qeye(2)) +
    tensor(qeye(2), sigmaz(), qeye(2)) +
    tensor(qeye(2), qeye(2), sigmaz()) +
    0.5  * tensor(sigmax(), sigmax(), qeye(2)) +
    0.25 * tensor(qeye(2), sigmax(), sigmax())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2, 2, 2]   size=(8, 8)   ishermitian=true
8×8 SparseMatrixCSC{ComplexF64, Int64} with 24 stored entries:
  3.0+0.0im       ⋅           ⋅      …       ⋅       0.5+0.0im       ⋅    
      ⋅       1.0+0.0im  0.25+0.0im          ⋅           ⋅       0.5+0.0im
      ⋅      0.25+0.0im   1.0+0.0im          ⋅           ⋅           ⋅    
 0.25+0.0im       ⋅           ⋅          0.5+0.0im       ⋅           ⋅    
      ⋅           ⋅       0.5+0.0im          ⋅           ⋅      0.25+0.0im
      ⋅           ⋅           ⋅      …  -1.0+0.0im  0.25+0.0im       ⋅    
  0.5+0.0im       ⋅           ⋅         0.25+0.0im  -1.0+0.0im       ⋅    
      ⋅       0.5+0.0im       ⋅              ⋅           ⋅      -3.0+0.0im</code></pre><h3 id="A-two-level-system-coupled-to-a-cavity:-The-Jaynes-Cummings-model"><a class="docs-heading-anchor" href="#A-two-level-system-coupled-to-a-cavity:-The-Jaynes-Cummings-model">A two-level system coupled to a cavity: The Jaynes-Cummings model</a><a id="A-two-level-system-coupled-to-a-cavity:-The-Jaynes-Cummings-model-1"></a><a class="docs-heading-anchor-permalink" href="#A-two-level-system-coupled-to-a-cavity:-The-Jaynes-Cummings-model" title="Permalink"></a></h3><p>The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity <span>$\omega_a$</span> and <span>$\omega_c$</span>, respectively, and the atom-cavity interaction strength <span>$g$</span>, the Jaynes-Cummings Hamiltonian can be constructed as:</p><p class="math-container">\[H = \frac{\omega_a}{2}\hat{\sigma}_z + \omega_c \hat{a}^\dagger \hat{a} + g (\hat{a}^\dagger \hat{\sigma}_- + \hat{a} \hat{\sigma}_+)\]</p><pre><code class="language-julia hljs">N = 6     # cavity fock space truncation
ωc = 1.25 # frequency of cavity
ωa = 1.0  # frequency of two-level atom
g = 0.75  # interaction strength

a = tensor(qeye(2), destroy(N)) # cavity annihilation operator

# two-level atom operators
σm = tensor(destroy(2), qeye(N))
σz = tensor(sigmaz(), qeye(N))

H = 0.5 * ωa * σz + ωc * a&#39; * a + g * (a&#39; * σm + a * σm&#39;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2, 6]   size=(12, 12)   ishermitian=true
12×12 SparseMatrixCSC{ComplexF64, Int64} with 22 stored entries:
 0.5+0.0im       ⋅              ⋅      …          ⋅           ⋅    
     ⋅      1.75+0.0im          ⋅                 ⋅           ⋅    
     ⋅           ⋅          3.0+0.0im             ⋅           ⋅    
     ⋅           ⋅              ⋅                 ⋅           ⋅    
     ⋅           ⋅              ⋅                 ⋅           ⋅    
     ⋅           ⋅              ⋅      …  1.67705+0.0im       ⋅    
     ⋅      0.75+0.0im          ⋅                 ⋅           ⋅    
     ⋅           ⋅      1.06066+0.0im             ⋅           ⋅    
     ⋅           ⋅              ⋅                 ⋅           ⋅    
     ⋅           ⋅              ⋅                 ⋅           ⋅    
     ⋅           ⋅              ⋅      …      4.5+0.0im       ⋅    
     ⋅           ⋅              ⋅                 ⋅      5.75+0.0im</code></pre><h2 id="doc:Partial-trace"><a class="docs-heading-anchor" href="#doc:Partial-trace">Partial trace</a><a id="doc:Partial-trace-1"></a><a class="docs-heading-anchor-permalink" href="#doc:Partial-trace" title="Permalink"></a></h2><p>The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In <code>QuantumToolbox</code> the function <a href="../../api/#QuantumToolbox.ptrace"><code>ptrace</code></a> is used to take partial traces. <a href="../../api/#QuantumToolbox.ptrace"><code>ptrace</code></a> takes one <a href="../../api/#QuantumToolbox.QuantumObject"><code>QuantumObject</code></a> as an input, and also one argument <code>sel</code>, which marks the component systems that should be kept, and all the other components are traced out. </p><p>Remember that the index of <code>Julia</code> starts from <code>1</code>, and all the elements in <code>sel</code> should be positive <code>Integer</code>. Therefore, the type of <code>sel</code> can be either <code>Integer</code>, <code>Tuple</code>, <code>SVector</code>, or <code>Vector</code>.</p><div class="admonition is-warning"><header class="admonition-header">Beware of type-stability!</header><div class="admonition-body"><p>Although it supports also <code>Vector</code> type, it is recommended to use <code>Tuple</code> or <code>SVector</code> from <a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArrays.jl</code></a> to improve performance. For a brief explanation on the impact of the type of <code>sel</code>, see the section <a href="../../type_stability/#doc:Type-Stability">The Importance of Type-Stability</a>.</p></div></div><p>For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:</p><pre><code class="language-julia hljs">ψ = tensor(
    basis(2, 0),
    basis(2, 1),
    normalize(basis(2, 0) + basis(2, 1))
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Ket   dims=[2, 2, 2]   size=(8,)
8-element Vector{ComplexF64}:
                0.0 + 0.0im
                0.0 + 0.0im
 0.7071067811865475 + 0.0im
 0.7071067811865475 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im</code></pre><pre><code class="language-julia hljs">ptrace(ψ, 1) # trace out 2nd and 3rd systems</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true
2×2 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im
 0.0-0.0im  0.0+0.0im</code></pre><pre><code class="language-julia hljs">ptrace(ψ, (1, 3)) # trace out 2nd system</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2, 2]   size=(4, 4)   ishermitian=true
4×4 Matrix{ComplexF64}:
 0.5+0.0im  0.5+0.0im  0.0+0.0im  0.0+0.0im
 0.5-0.0im  0.5+0.0im  0.0+0.0im  0.0+0.0im
 0.0-0.0im  0.0-0.0im  0.0+0.0im  0.0+0.0im
 0.0-0.0im  0.0-0.0im  0.0-0.0im  0.0+0.0im</code></pre><p>Note that the partial trace always results in a <a href="../../api/#QuantumToolbox.Operator"><code>Operator</code></a> (density matrix), regardless of whether the composite system is a pure state (described by a <a href="../../api/#QuantumToolbox.Ket"><code>Ket</code></a>) or a mixed state (described by a <a href="../../api/#QuantumToolbox.Operator"><code>Operator</code></a>):</p><pre><code class="language-julia hljs">ψ1 = normalize(basis(2, 0) + basis(2, 1))
ψ2 = basis(2, 0)
ψT = tensor(ψ1, ψ2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Ket   dims=[2, 2]   size=(4,)
4-element Vector{ComplexF64}:
 0.7071067811865475 + 0.0im
                0.0 + 0.0im
 0.7071067811865475 + 0.0im
                0.0 + 0.0im</code></pre><pre><code class="language-julia hljs">ptrace(ψT, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true
2×2 Matrix{ComplexF64}:
 0.5+0.0im  0.5+0.0im
 0.5+0.0im  0.5+0.0im</code></pre><pre><code class="language-julia hljs">ρT = tensor(ket2dm(ψ1), ket2dm(ψ1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2, 2]   size=(4, 4)   ishermitian=true
4×4 Matrix{ComplexF64}:
 0.25+0.0im  0.25+0.0im  0.25+0.0im  0.25+0.0im
 0.25+0.0im  0.25+0.0im  0.25+0.0im  0.25+0.0im
 0.25+0.0im  0.25+0.0im  0.25+0.0im  0.25+0.0im
 0.25+0.0im  0.25+0.0im  0.25+0.0im  0.25+0.0im</code></pre><pre><code class="language-julia hljs">ptrace(ρT, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Quantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true
2×2 Matrix{ComplexF64}:
 0.5+0.0im  0.5+0.0im
 0.5+0.0im  0.5+0.0im</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../states_and_operators/">« Manipulating States and Operators</a><a class="docs-footer-nextpage" href="../time_evolution/intro/">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 4 October 2024 14:38">Friday 4 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
