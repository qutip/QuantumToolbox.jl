var documenterSearchIndex = {"docs":
[{"location":"users_guide/states_and_operators/#doc:States-and-Operators","page":"Manipulating States and Operators","title":"States and Operators","text":"","category":"section"},{"location":"users_guide/states_and_operators/","page":"Manipulating States and Operators","title":"Manipulating States and Operators","text":"This page is still under construction, please visit API first.","category":"page"},{"location":"users_guide/states_and_operators/#Introduction","page":"Manipulating States and Operators","title":"Introduction","text":"","category":"section"},{"location":"users_guide/states_and_operators/#doc:-State-vectors","page":"Manipulating States and Operators","title":"State Vectors (kets or bras)","text":"","category":"section"},{"location":"users_guide/states_and_operators/#doc:-Density-matrices","page":"Manipulating States and Operators","title":"Density matrices","text":"","category":"section"},{"location":"users_guide/states_and_operators/#doc:-Two-level-systems","page":"Manipulating States and Operators","title":"Two-level systems (qubits)","text":"","category":"section"},{"location":"users_guide/states_and_operators/#doc:-Expectation-values","page":"Manipulating States and Operators","title":"Expectation values","text":"","category":"section"},{"location":"users_guide/states_and_operators/#doc:-Superoperators-and-Vectorized-Operators","page":"Manipulating States and Operators","title":"Superoperators and Vectorized Operators","text":"","category":"section"},{"location":"users_guide/states_and_operators/#doc:-Generating-Random-States-and-Operators","page":"Manipulating States and Operators","title":"Generating Random States and Operators","text":"","category":"section"},{"location":"users_guide/tensor/#doc:Tensor-products","page":"Tensor Products and Partial Traces","title":"Tensor products","text":"","category":"section"},{"location":"users_guide/tensor/","page":"Tensor Products and Partial Traces","title":"Tensor Products and Partial Traces","text":"This page is still under construction, please visit API first.","category":"page"},{"location":"benchmarks/benchmark_history/","page":"Solver Benchmarks","title":"Solver Benchmarks","text":"<iframe id=\"myIframe\" src=\"https://qutip.github.io/QuantumToolbox.jl/benchmarks/\" style=\"width:100%; border:none; overflow:hidden;\"></iframe>\n\n\n<script>\n  // Function to adjust the iframe height\n  function adjustIframeHeight(event) {\n    const iframe = document.getElementById('myIframe');\n    iframe.style.height = event.data + 'px';\n  }\n\n  // Listen for messages from the iframe\n  window.addEventListener('message', adjustIframeHeight, false);\n</script>\n","category":"page"},{"location":"users_guide/time_evolution/intro/#doc:Time-Evolution-and-Quantum-System-Dynamics","page":"Introduction","title":"Time Evolution and Quantum System Dynamics","text":"","category":"section"},{"location":"users_guide/time_evolution/intro/","page":"Introduction","title":"Introduction","text":"This page is still under construction, please visit API first.","category":"page"},{"location":"users_guide/QuantumObject/QuantumObject_functions/#doc:Functions-operating-on-Qobj","page":"Functions operating on Qobj","title":"Functions operating on Qobj","text":"","category":"section"},{"location":"users_guide/QuantumObject/QuantumObject_functions/","page":"Functions operating on Qobj","title":"Functions operating on Qobj","text":"This page is still under construction, please visit API first.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = QuantumToolbox","category":"page"},{"location":"api/#doc-API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Contents","page":"API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#doc-API:Quantum-object-and-type","page":"API","title":"Quantum object (Qobj) and type","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"BraQuantumObject\nBra\nKetQuantumObject\nKet\nOperatorQuantumObject\nOperator\nOperatorBraQuantumObject\nOperatorBra\nOperatorKetQuantumObject\nOperatorKet\nSuperOperatorQuantumObject\nSuperOperator\nQuantumObject\nsize\neltype\nlength\nisbra\nisket\nisoper\nisoperbra\nisoperket\nissuper\nLinearAlgebra.ishermitian\nLinearAlgebra.issymmetric\nLinearAlgebra.isposdef","category":"page"},{"location":"api/#QuantumToolbox.BraQuantumObject","page":"API","title":"QuantumToolbox.BraQuantumObject","text":"BraQuantumObject <: QuantumObjectType\n\nConstructor representing a bra state langlepsi.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.Bra","page":"API","title":"QuantumToolbox.Bra","text":"const Bra = BraQuantumObject()\n\nA constant representing the type of BraQuantumObject: a bra state langlepsi\n\n\n\n\n\n","category":"constant"},{"location":"api/#QuantumToolbox.KetQuantumObject","page":"API","title":"QuantumToolbox.KetQuantumObject","text":"KetQuantumObject <: QuantumObjectType\n\nConstructor representing a ket state psirangle.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.Ket","page":"API","title":"QuantumToolbox.Ket","text":"const Ket = KetQuantumObject()\n\nA constant representing the type of KetQuantumObject: a ket state psirangle\n\n\n\n\n\n","category":"constant"},{"location":"api/#QuantumToolbox.OperatorQuantumObject","page":"API","title":"QuantumToolbox.OperatorQuantumObject","text":"OperatorQuantumObject <: QuantumObjectType\n\nConstructor representing an operator hatO.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.Operator","page":"API","title":"QuantumToolbox.Operator","text":"const Operator = OperatorQuantumObject()\n\nA constant representing the type of OperatorQuantumObject: an operator hatO\n\n\n\n\n\n","category":"constant"},{"location":"api/#QuantumToolbox.OperatorBraQuantumObject","page":"API","title":"QuantumToolbox.OperatorBraQuantumObject","text":"OperatorBraQuantumObject <: QuantumObjectType\n\nConstructor representing a bra state in the SuperOperator formalism langlelanglerho.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.OperatorBra","page":"API","title":"QuantumToolbox.OperatorBra","text":"const OperatorBra = OperatorBraQuantumObject()\n\nA constant representing the type of OperatorBraQuantumObject: a bra state in the SuperOperator formalism langlelanglerho.\n\n\n\n\n\n","category":"constant"},{"location":"api/#QuantumToolbox.OperatorKetQuantumObject","page":"API","title":"QuantumToolbox.OperatorKetQuantumObject","text":"OperatorKetQuantumObject <: QuantumObjectType\n\nConstructor representing a ket state in the SuperOperator formalism rhoranglerangle.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.OperatorKet","page":"API","title":"QuantumToolbox.OperatorKet","text":"const OperatorKet = OperatorKetQuantumObject()\n\nA constant representing the type of OperatorKetQuantumObject: a ket state in the SuperOperator formalism rhoranglerangle\n\n\n\n\n\n","category":"constant"},{"location":"api/#QuantumToolbox.SuperOperatorQuantumObject","page":"API","title":"QuantumToolbox.SuperOperatorQuantumObject","text":"SuperOperatorQuantumObject <: QuantumObjectType\n\nConstructor representing a super-operator hatmathcalO acting on vectorized density operator matrices.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.SuperOperator","page":"API","title":"QuantumToolbox.SuperOperator","text":"const SuperOperator = SuperOperatorQuantumObject()\n\nA constant representing the type of SuperOperatorQuantumObject: a super-operator hatmathcalO acting on vectorized density operator matrices\n\n\n\n\n\n","category":"constant"},{"location":"api/#QuantumToolbox.QuantumObject","page":"API","title":"QuantumToolbox.QuantumObject","text":"struct QuantumObject{MT<:AbstractArray,ObjType<:QuantumObjectType}\n    data::MT\n    type::ObjType\n    dims::Vector{Int}\nend\n\nJulia struct representing any quantum objects.\n\nExamples\n\njulia> a = destroy(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢\n\njulia> a isa QuantumObject\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.size","page":"API","title":"Base.size","text":"size(A::QuantumObject)\nsize(A::QuantumObject, idx::Int)\n\nReturns a tuple containing each dimensions of the array in the QuantumObject.\n\nOptionally, you can specify an index (idx) to just get the corresponding dimension of the array.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.eltype","page":"API","title":"Base.eltype","text":"eltype(A::QuantumObject)\n\nReturns the elements type of the matrix or vector corresponding to the QuantumObject A.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.length","page":"API","title":"Base.length","text":"length(A::QuantumObject)\n\nReturns the length of the matrix or vector corresponding to the QuantumObject A.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.isbra","page":"API","title":"QuantumToolbox.isbra","text":"isbra(A::QuantumObject)\n\nChecks if the QuantumObject A is a BraQuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.isket","page":"API","title":"QuantumToolbox.isket","text":"isket(A::QuantumObject)\n\nChecks if the QuantumObject A is a KetQuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.isoper","page":"API","title":"QuantumToolbox.isoper","text":"isoper(A::QuantumObject)\n\nChecks if the QuantumObject A is a OperatorQuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.isoperbra","page":"API","title":"QuantumToolbox.isoperbra","text":"isoperbra(A::QuantumObject)\n\nChecks if the QuantumObject A is a OperatorBraQuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.isoperket","page":"API","title":"QuantumToolbox.isoperket","text":"isoperket(A::QuantumObject)\n\nChecks if the QuantumObject A is a OperatorKetQuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.issuper","page":"API","title":"QuantumToolbox.issuper","text":"issuper(A::QuantumObject)\n\nChecks if the QuantumObject A is a SuperOperatorQuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.ishermitian","page":"API","title":"LinearAlgebra.ishermitian","text":"ishermitian(A::QuantumObject)\n\nTest whether the QuantumObject is Hermitian.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.issymmetric","page":"API","title":"LinearAlgebra.issymmetric","text":"issymmetric(A::QuantumObject)\n\nTest whether the QuantumObject is symmetric.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.isposdef","page":"API","title":"LinearAlgebra.isposdef","text":"isposdef(A::QuantumObject)\n\nTest whether the QuantumObject is positive definite (and Hermitian) by trying to perform a Cholesky factorization of A.\n\n\n\n\n\n","category":"function"},{"location":"api/#doc-API:Qobj-arithmetic-and-attributes","page":"API","title":"Qobj arithmetic and attributes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Base.conj\nLinearAlgebra.transpose\nLinearAlgebra.adjoint\nLinearAlgebra.dot\nLinearAlgebra.sqrt\nLinearAlgebra.log\nLinearAlgebra.exp\nLinearAlgebra.sin\nLinearAlgebra.cos\nLinearAlgebra.tr\nLinearAlgebra.svdvals\nLinearAlgebra.norm\nLinearAlgebra.normalize\nLinearAlgebra.normalize!\nLinearAlgebra.inv\nLinearAlgebra.diag\nproj\nptrace\npurity\npermute\ntidyup\ntidyup!\nget_data\nget_coherence\npartial_transpose","category":"page"},{"location":"api/#Base.conj","page":"API","title":"Base.conj","text":"conj(A::QuantumObject)\n\nReturn the element-wise complex conjugation of the QuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.transpose","page":"API","title":"Base.transpose","text":"transpose(A::QuantumObject)\n\nLazy matrix transpose of the QuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.adjoint","page":"API","title":"Base.adjoint","text":"A'\nadjoint(A::QuantumObject)\n\nLazy adjoint (conjugate transposition) of the QuantumObject\n\nNote that A' is a synonym for adjoint(A)\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.dot","page":"API","title":"LinearAlgebra.dot","text":"dot(A::QuantumObject, B::QuantumObject)\n\nCompute the dot product between two QuantumObject: langle A  B rangle\n\nNote that A and B should be Ket or OperatorKet\n\nA ⋅ B (where ⋅ can be typed by tab-completing \\cdot in the REPL) is a synonym for dot(A, B)\n\n\n\n\n\ndot(i::QuantumObject, A::QuantumObject j::QuantumObject)\n\nCompute the generalized dot product dot(i, A*j) between three QuantumObject: langle i  A  j rangle\n\nSupports the following inputs:\n\nA is in the type of Operator, with i and j are both Ket.\nA is in the type of SuperOperator, with i and j are both OperatorKet\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.sqrt","page":"API","title":"Base.sqrt","text":"√(A)\nsqrt(A::QuantumObject)\n\nMatrix square root of QuantumObject\n\nNote that √(A) is a synonym for sqrt(A)\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.log","page":"API","title":"Base.log","text":"log(A::QuantumObject)\n\nMatrix logarithm of QuantumObject\n\nNote that this function only supports for Operator and SuperOperator\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.exp","page":"API","title":"Base.exp","text":"exp(A::QuantumObject)\n\nMatrix exponential of QuantumObject\n\nNote that this function only supports for Operator and SuperOperator\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.sin","page":"API","title":"Base.sin","text":"sin(A::QuantumObject)\n\nMatrix sine of QuantumObject, defined as\n\nsin left( hatA right) = frace^i hatA - e^-i hatA2 i\n\nNote that this function only supports for Operator and SuperOperator\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.cos","page":"API","title":"Base.cos","text":"cos(A::QuantumObject)\n\nMatrix cosine of QuantumObject, defined as\n\ncos left( hatA right) = frace^i hatA + e^-i hatA2\n\nNote that this function only supports for Operator and SuperOperator\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.tr","page":"API","title":"LinearAlgebra.tr","text":"tr(A::QuantumObject)\n\nReturns the trace of QuantumObject.\n\nNote that this function only supports for Operator and SuperOperator\n\nExamples\n\njulia> a = destroy(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢\n\njulia> tr(a' * a)\n190.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.svdvals","page":"API","title":"LinearAlgebra.svdvals","text":"svdvals(A::QuantumObject)\n\nReturn the singular values of a QuantumObject in descending order\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.norm","page":"API","title":"LinearAlgebra.norm","text":"norm(A::QuantumObject, p::Real)\n\nReturn the standard vector p-norm or Schatten p-norm of a QuantumObject depending on the type of A:\n\nIf A is either Ket, Bra, OperatorKet, or OperatorBra, returns the standard vector p-norm (default p=2) of A.\nIf A is either Operator or SuperOperator, returns Schatten p-norm (default p=1) of A.\n\nExamples\n\njulia> ψ = fock(10, 2)\nQuantum Object:   type=Ket   dims=[10]   size=(10,)\n10-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\njulia> norm(ψ)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.normalize","page":"API","title":"LinearAlgebra.normalize","text":"normalize(A::QuantumObject, p::Real)\n\nReturn normalized QuantumObject so that its p-norm equals to unity, i.e. norm(A, p) == 1.\n\nSupport for the following types of QuantumObject:\n\nIf A is Ket or Bra, default p = 2\nIf A is Operator, default p = 1\n\nAlso, see norm about its definition for different types of QuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.normalize!","page":"API","title":"LinearAlgebra.normalize!","text":"normalize!(A::QuantumObject, p::Real)\n\nNormalize QuantumObject in-place so that its p-norm equals to unity, i.e. norm(A, p) == 1.\n\nSupport for the following types of QuantumObject:\n\nIf A is Ket or Bra, default p = 2\nIf A is Operator, default p = 1\n\nAlso, see norm about its definition for different types of QuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.inv","page":"API","title":"Base.inv","text":"inv(A::QuantumObject)\n\nMatrix inverse of the QuantumObject\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.diag","page":"API","title":"LinearAlgebra.diag","text":"diag(A::QuantumObject, k::Int=0)\n\nReturn the k-th diagonal elements of a matrix-type QuantumObject\n\nNote that this function only supports for Operator and SuperOperator\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.proj","page":"API","title":"QuantumToolbox.proj","text":"proj(ψ::QuantumObject)\n\nReturn the projector for a Ket or Bra type of QuantumObject\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.ptrace","page":"API","title":"QuantumToolbox.ptrace","text":"ptrace(QO::QuantumObject, sel::Vector{Int})\n\nPartial trace of a quantum state QO leaving only the dimensions with the indices present in the sel vector.\n\nExamples\n\nTwo qubits in the state ketpsi = keteg:\n\njulia> ψ = kron(fock(2,0), fock(2,1))\nQuantum Object:   type=Ket   dims=[2, 2]   size=(4,)\n4-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\njulia> ptrace(ψ, [2])\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im\n\nor in an entangled state ketpsi = frac1sqrt2 left( ketee + ketgg right):\n\njulia> ψ = 1 / √2 * (kron(fock(2,0), fock(2,0)) + kron(fock(2,1), fock(2,1)))\nQuantum Object:   type=Ket   dims=[2, 2]   size=(4,)\n4-element Vector{ComplexF64}:\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n\njulia> ptrace(ψ, [1])\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true\n2×2 Matrix{ComplexF64}:\n 0.5+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.purity","page":"API","title":"QuantumToolbox.purity","text":"purity(ρ::QuantumObject)\n\nCalculate the purity of a QuantumObject: textrmTr(rho^2)\n\nNote that this function only supports for Ket, Bra, and Operator\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.permute","page":"API","title":"QuantumToolbox.permute","text":"permute(A::QuantumObject, order::Vector{Int})\n\nPermute the tensor structure of a QuantumObject A according to the specified order list\n\nNote that this method currently works for Ket, Bra, and Operator types of QuantumObject.\n\nExamples\n\nIf order = [2, 1, 3], the Hilbert space structure will be re-arranged: H₁ ⊗ H₂ ⊗ H₃ → H₂ ⊗ H₁ ⊗ H₃.\n\njulia> ψ1 = fock(2, 0)\njulia> ψ2 = fock(3, 1)\njulia> ψ3 = fock(4, 2)\njulia> ψ_123 = tensor(ψ1, ψ2, ψ3)\njulia> permute(ψ_123, [2, 1, 3]) ≈ tensor(ψ2, ψ1, ψ3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.tidyup","page":"API","title":"QuantumToolbox.tidyup","text":"tidyup(A::QuantumObject, tol::Real=1e-14)\n\nRemoves those elements of a QuantumObject A whose absolute value is less than tol.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.tidyup!","page":"API","title":"QuantumToolbox.tidyup!","text":"tidyup!(A::QuantumObject, tol::Real=1e-14)\n\nRemoves those elements of a QuantumObject A whose absolute value is less than tol.\n\nNote that this function is an in-place version of tidyup.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.get_data","page":"API","title":"QuantumToolbox.get_data","text":"get_data(A::QuantumObject)\n\nReturns the data of a QuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.get_coherence","page":"API","title":"QuantumToolbox.get_coherence","text":"get_coherence(ψ::QuantumObject)\n\nGet the coherence value alpha by measuring the expectation value of the destruction operator hata on a state ketpsi or a density matrix hatrho.\n\nIt returns both alpha and the corresponding state with the coherence removed: ketdelta_alpha = exp ( baralpha hata - alpha hata^dagger ) ketpsi for a pure state, and hatrho_alpha = exp ( baralpha hata - alpha hata^dagger ) hatrho exp ( -baralpha hata + alpha hata^dagger ) for a density matrix. These states correspond to the quantum fluctuations around the coherent state ketalpha or dyadalpha.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.partial_transpose","page":"API","title":"QuantumToolbox.partial_transpose","text":"partial_transpose(ρ::QuantumObject, mask::Vector{Bool})\n\nReturn the partial transpose of a density matrix rho, where mask is an array/vector with length that equals the length of ρ.dims. The elements in mask are boolean (true or false) which indicates whether or not the corresponding subsystem should be transposed.\n\nArguments\n\nρ::QuantumObject: The density matrix (ρ.type must be OperatorQuantumObject).\nmask::Vector{Bool}: A boolean vector selects which subsystems should be transposed.\n\nReturns\n\nρ_pt::QuantumObject: The density matrix with the selected subsystems transposed.\n\n\n\n\n\n","category":"function"},{"location":"api/#doc-API:Qobj-eigenvalues-and-eigenvectors","page":"API","title":"Qobj eigenvalues and eigenvectors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"EigsolveResult\neigenenergies\neigenstates\nLinearAlgebra.eigen\nLinearAlgebra.eigvals\neigsolve\neigsolve_al","category":"page"},{"location":"api/#QuantumToolbox.EigsolveResult","page":"API","title":"QuantumToolbox.EigsolveResult","text":"struct EigsolveResult{T1<:Vector{<:Number}, T2<:AbstractMatrix{<:Number}, ObjType<:Union{Nothing,OperatorQuantumObject,SuperOperatorQuantumObject}}\n    values::T1\n    vectors::T2\n    type::ObjType\n    dims::Vector{Int}\n    iter::Int\n    numops::Int\n    converged::Bool\nend\n\nA struct containing the eigenvalues, the eigenvectors, and some information from the solver\n\nFields\n\nvalues::AbstractVector: the eigenvalues\nvectors::AbstractMatrix: the transformation matrix (eigenvectors)\ntype::Union{Nothing,QuantumObjectType}: the type of QuantumObject, or nothing means solving eigen equation for general matrix\ndims::Vector{Int}: the dims of QuantumObject\niter::Int: the number of iteration during the solving process\nnumops::Int : number of times the linear map was applied in krylov methods\nconverged::Bool: Whether the result is converged\n\nExamples\n\nOne can obtain the eigenvalues and the corresponding QuantumObject-type eigenvectors by:\n\njulia> result = eigenstates(sigmax());\n\njulia> λ, ψ, T = result;\n\njulia> λ\n2-element Vector{ComplexF64}:\n -1.0 + 0.0im\n  1.0 + 0.0im\n\njulia> ψ\n2-element Vector{QuantumObject{Vector{ComplexF64}, KetQuantumObject}}:\n QuantumObject{Vector{ComplexF64}, KetQuantumObject}(ComplexF64[-0.7071067811865475 + 0.0im, 0.7071067811865475 + 0.0im], KetQuantumObject(), [2])\n QuantumObject{Vector{ComplexF64}, KetQuantumObject}(ComplexF64[0.7071067811865475 + 0.0im, 0.7071067811865475 + 0.0im], KetQuantumObject(), [2])\n\njulia> T\n2×2 Matrix{ComplexF64}:\n -0.707107+0.0im  0.707107+0.0im\n  0.707107+0.0im  0.707107+0.0im\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.eigenenergies","page":"API","title":"QuantumToolbox.eigenenergies","text":"eigenenergies(A::QuantumObject; sparse::Bool=false, kwargs...)\n\nCalculate the eigenenergies\n\nArguments\n\nA::QuantumObject: the QuantumObject to solve eigenvalues\nsparse::Bool: if false call eigvals(A::QuantumObject; kwargs...), otherwise call eigsolve. Default to false.\nkwargs: Additional keyword arguments passed to the solver\n\nReturns\n\n::Vector{<:Number}: a list of eigenvalues\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.eigenstates","page":"API","title":"QuantumToolbox.eigenstates","text":"eigenstates(A::QuantumObject; sparse::Bool=false, kwargs...)\n\nCalculate the eigenvalues and corresponding eigenvectors\n\nArguments\n\nA::QuantumObject: the QuantumObject to solve eigenvalues and eigenvectors\nsparse::Bool: if false call eigen(A::QuantumObject; kwargs...), otherwise call eigsolve. Default to false.\nkwargs: Additional keyword arguments passed to the solver\n\nReturns\n\n::EigsolveResult: containing the eigenvalues, the eigenvectors, and some information from the solver. see also EigsolveResult\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.eigen","page":"API","title":"LinearAlgebra.eigen","text":"LinearAlgebra.eigen(A::QuantumObject; kwargs...)\n\nCalculates the eigenvalues and eigenvectors of the QuantumObject A using the Julia LinearAlgebra package.\n\njulia> a = destroy(5);\n\njulia> H = a + a'\nQuantum Object:   type=Operator   dims=[5]   size=(5, 5)   ishermitian=true\n5×5 SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n     ⋅          1.0+0.0im          ⋅              ⋅          ⋅\n 1.0+0.0im          ⋅      1.41421+0.0im          ⋅          ⋅\n     ⋅      1.41421+0.0im          ⋅      1.73205+0.0im      ⋅\n     ⋅              ⋅      1.73205+0.0im          ⋅      2.0+0.0im\n     ⋅              ⋅              ⋅          2.0+0.0im      ⋅\n\njulia> E, ψ, U = eigen(H)\nEigsolveResult:   type=Operator   dims=[5]\nvalues:\n5-element Vector{Float64}:\n -2.8569700138728\n -1.3556261799742608\n  1.3322676295501878e-15\n  1.3556261799742677\n  2.8569700138728056\nvectors:\n5×5 Matrix{ComplexF64}:\n  0.106101+0.0im  -0.471249-0.0im  …   0.471249-0.0im  0.106101-0.0im\n -0.303127-0.0im   0.638838+0.0im      0.638838+0.0im  0.303127-0.0im\n  0.537348+0.0im  -0.279149-0.0im      0.279149-0.0im  0.537348-0.0im\n -0.638838-0.0im  -0.303127-0.0im     -0.303127-0.0im  0.638838+0.0im\n  0.447214+0.0im   0.447214+0.0im     -0.447214-0.0im  0.447214-0.0im\n\njulia> expect(H, ψ[1]) ≈ E[1]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.eigvals","page":"API","title":"LinearAlgebra.eigvals","text":"LinearAlgebra.eigvals(A::QuantumObject; kwargs...)\n\nSame as eigen(A::QuantumObject; kwargs...) but for only the eigenvalues.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.eigsolve","page":"API","title":"QuantumToolbox.eigsolve","text":"function eigsolve(A::QuantumObject; v0::Union{Nothing,AbstractVector}=nothing, \n    sigma::Union{Nothing, Real}=nothing, k::Int = 1, \n    krylovdim::Int = max(20, 2*k+1), tol::Real = 1e-8, maxiter::Int = 200,\n    solver::Union{Nothing, LinearSolve.SciMLLinearSolveAlgorithm} = nothing, kwargs...)\n\nSolve for the eigenvalues and eigenvectors of a matrix A using the Arnoldi method. The keyword arguments are passed to the linear solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.eigsolve_al","page":"API","title":"QuantumToolbox.eigsolve_al","text":"eigsolve_al(H::QuantumObject,\n    T::Real, c_ops::AbstractVector=[];\n    alg::OrdinaryDiffEqAlgorithm=Tsit5(),\n    H_t::Union{Nothing,Function}=nothing,\n    params::NamedTuple=NamedTuple(),\n    ρ0::Union{Nothing, AbstractMatrix} = nothing,\n    k::Int=1,\n    krylovdim::Int=min(10, size(H, 1)),\n    maxiter::Int=200,\n    eigstol::Real=1e-6,\n    kwargs...)\n\nSolve the eigenvalue problem for a Liouvillian superoperator L using the Arnoldi-Lindblad method.\n\nArguments\n\nH: The Hamiltonian (or directly the Liouvillian) of the system.\nT: The time at which to evaluate the time evolution\nc_ops: A vector of collapse operators\nalg: The differential equation solver algorithm\nH_t: A function H_t(t) that returns the additional term at time t\nparams: A dictionary of additional parameters\nρ0: The initial density matrix. If not specified, a random density matrix is used\nk: The number of eigenvalues to compute\nkrylovdim: The dimension of the Krylov subspace\nmaxiter: The maximum number of iterations for the eigsolver\neigstol: The tolerance for the eigsolver\nkwargs: Additional keyword arguments passed to the differential equation solver\n\nReturns\n\nEigsolveResult: A struct containing the eigenvalues, the eigenvectors, and some information about the eigsolver\n\nReferences\n\n[1] Minganti, F., & Huybrechts, D. (2022). Arnoldi-Lindblad time evolution: \n\nFaster-than-the-clock algorithm for the spectrum of time-independent  and Floquet open quantum systems. Quantum, 6, 649.\n\n\n\n\n\n","category":"function"},{"location":"api/#doc-API:Qobj-manipulation","page":"API","title":"Qobj manipulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ket2dm\nexpect\nLinearAlgebra.kron\nsparse_to_dense\ndense_to_sparse\nvec2mat\nmat2vec","category":"page"},{"location":"api/#QuantumToolbox.ket2dm","page":"API","title":"QuantumToolbox.ket2dm","text":"ket2dm(ψ::QuantumObject)\n\nTransform the ket state ketpsi into a pure density matrix hatrho = dyadpsi.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.expect","page":"API","title":"QuantumToolbox.expect","text":"expect(O::QuantumObject, ψ::QuantumObject)\n\nExpectation value of the operator O with the state ψ. The latter can be a KetQuantumObject, BraQuantumObject or a OperatorQuantumObject. If ψ is a density matrix, the function calculates Tr left hatO hatpsi right, while if ψ is a state, the function calculates melpsihatOpsi.\n\nThe function returns a real number if the operator is hermitian, and returns a complex number otherwise.\n\nExamples\n\njulia> ψ = 1 / √2 * (fock(10,2) + fock(10,4));\n\njulia> a = destroy(10);\n\njulia> expect(a' * a, ψ) ≈ 3\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.kron","page":"API","title":"Base.kron","text":"kron(A::QuantumObject, B::QuantumObject, ...)\n\nReturns the Kronecker product hatA otimes hatB otimes cdots.\n\nExamples\n\njulia> a = destroy(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢\n\njulia> kron(a, a)\nQuantum Object:   type=Operator   dims=[20, 20]   size=(400, 400)   ishermitian=false\n400×400 SparseMatrixCSC{ComplexF64, Int64} with 361 stored entries:\n⠀⠀⠘⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠦\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sparse_to_dense","page":"API","title":"QuantumToolbox.sparse_to_dense","text":"sparse_to_dense(A::QuantumObject)\n\nConverts a sparse QuantumObject to a dense QuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.dense_to_sparse","page":"API","title":"QuantumToolbox.dense_to_sparse","text":"dense_to_sparse(A::QuantumObject)\n\nConverts a dense QuantumObject to a sparse QuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.vec2mat","page":"API","title":"QuantumToolbox.vec2mat","text":"vec2mat(A::AbstractVector)\n\nConverts a vector to a matrix.\n\n\n\n\n\nvec2mat(A::QuantumObject)\n\nConvert a quantum object from vector (OperatorKetQuantumObject-type) to matrix (OperatorQuantumObject-type)\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mat2vec","page":"API","title":"QuantumToolbox.mat2vec","text":"mat2vec(A::QuantumObject)\n\nConvert a quantum object from matrix (OperatorQuantumObject-type) to vector (OperatorKetQuantumObject-type)\n\n\n\n\n\nmat2vec(A::AbstractMatrix)\n\nConverts a matrix to a vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#doc-API:Generate-states-and-operators","page":"API","title":"Generate states and operators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"zero_ket\nfock\nbasis\ncoherent\nfock_dm\ncoherent_dm\nthermal_dm\nmaximally_mixed_dm\nrand_dm\nspin_state\nspin_coherent\nbell_state\nsinglet_state\ntriplet_states\nw_state\nghz_state\nsigmap\nsigmam\nsigmax\nsigmay\nsigmaz\njmat\nspin_Jx\nspin_Jy\nspin_Jz\nspin_Jm\nspin_Jp\nspin_J_set\ndestroy\ncreate\ndisplace\nsqueeze\nnum\nQuantumToolbox.position\nQuantumToolbox.momentum\nphase\nfdestroy\nfcreate\ntunneling\nqft\neye\nprojection\ncommutator\nspre\nspost\nsprepost\nlindblad_dissipator","category":"page"},{"location":"api/#QuantumToolbox.zero_ket","page":"API","title":"QuantumToolbox.zero_ket","text":"zero_ket(dimensions)\n\nReturns a zero Ket vector with given argument dimensions.\n\nThe dimensions can be either the following types:\n\ndimensions::Int: Number of basis states in the Hilbert space.\ndimensions::Vector{Int}: list of dimensions representing the each number of basis in the subsystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.fock","page":"API","title":"QuantumToolbox.fock","text":"fock(N::Int, pos::Int=0; dims::Vector{Int}=[N], sparse::Bool=false)\n\nGenerates a fock state ketpsi of dimension N. \n\nIt is also possible to specify the list of dimensions dims if different subsystems are present.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.basis","page":"API","title":"QuantumToolbox.basis","text":"basis(N::Int, pos::Int = 0; dims::Vector{Int}=[N])\n\nGenerates a fock state like fock.\n\nIt is also possible to specify the list of dimensions dims if different subsystems are present.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.coherent","page":"API","title":"QuantumToolbox.coherent","text":"coherent(N::Int, α::Number)\n\nGenerates a coherent state alpharangle, which is defined as an eigenvector of the bosonic annihilation operator hata alpharangle = alpha alpharangle.\n\nThis state is constructed via the displacement operator displace and zero-fock state fock: alpharangle = hatD(alpha) 0rangle\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.fock_dm","page":"API","title":"QuantumToolbox.fock_dm","text":"fock_dm(N::Int, pos::Int=0; dims::Vector{Int}=[N], sparse::Bool=false)\n\nDensity matrix representation of a Fock state.\n\nConstructed via outer product of fock.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.coherent_dm","page":"API","title":"QuantumToolbox.coherent_dm","text":"coherent_dm(N::Int, α::Number)\n\nDensity matrix representation of a coherent state.\n\nConstructed via outer product of coherent.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.thermal_dm","page":"API","title":"QuantumToolbox.thermal_dm","text":"thermal_dm(N::Int, n::Real; sparse::Bool=false)\n\nDensity matrix for a thermal state (generating thermal state probabilities) with the following arguments:\n\nN::Int: Number of basis states in the Hilbert space\nn::Real: Expectation value for number of particles in the thermal state.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.maximally_mixed_dm","page":"API","title":"QuantumToolbox.maximally_mixed_dm","text":"maximally_mixed_dm(dimensions)\n\nReturns the maximally mixed density matrix with given argument dimensions.\n\nThe dimensions can be either the following types:\n\ndimensions::Int: Number of basis states in the Hilbert space.\ndimensions::Vector{Int}: list of dimensions representing the each number of basis in the subsystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.rand_dm","page":"API","title":"QuantumToolbox.rand_dm","text":"rand_dm(N::Integer; dims::Vector{Int}=[N])\n\nGenerates a random density matrix hatrho, with the property to be positive semi-definite and textrmTr left hatrho right = 1.\n\nIt is also possible to specify the list of dimensions dims if different subsystems are present.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spin_state","page":"API","title":"QuantumToolbox.spin_state","text":"spin_state(j::Real, m::Real)\n\nGenerate the spin state: j mrangle\n\nThe eigenstate of the Spin-j S_z operator with eigenvalue m, where where j is the spin quantum number and can be a non-negative integer or half-integer\n\nSee also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spin_coherent","page":"API","title":"QuantumToolbox.spin_coherent","text":"spin_coherent(j::Real, θ::Real, ϕ::Real)\n\nGenerate the coherent spin state (rotation of the j jrangle state), namely\n\ntheta phi rangle = R(theta phi) j jrangle\n\nwhere the rotation operator is defined as\n\nR(theta phi) = exp left( fractheta2 (S_- e^iphi - S_+ e^-iphi) right)\n\nArguments\n\nj::Real: The spin quantum number and can be a non-negative integer or half-integer\nθ::Real: rotation angle from z-axis\nϕ::Real: rotation angle from x-axis\n\nSee also jmat and spin_state.\n\nReference\n\nRobert Jones, Spin Coherent States and Statistical Physics\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.bell_state","page":"API","title":"QuantumToolbox.bell_state","text":"bell_state(x::Int, z::Int)\n\nReturn the Bell state depending on the arguments (x, z):\n\n(0, 0):  Phi^+ rangle = ( 00rangle + 11rangle )  sqrt2\n(0, 1):  Phi^- rangle = ( 00rangle - 11rangle )  sqrt2\n(1, 0):  Psi^+ rangle = ( 01rangle + 10rangle )  sqrt2\n(1, 1):  Psi^- rangle = ( 01rangle - 10rangle )  sqrt2\n\nHere, x = 1 (z = 1) means applying Pauli-X ( Pauli-Z) unitary transformation on  Phi^+ rangle.\n\nExample\n\njulia> bell_state(0, 0)\nQuantum Object:   type=Ket   dims=[2, 2]   size=(4,)\n4-element Vector{ComplexF64}:\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.singlet_state","page":"API","title":"QuantumToolbox.singlet_state","text":"singlet_state()\n\nReturn the two particle singlet state: frac1sqrt2 ( 01rangle - 10rangle )\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.triplet_states","page":"API","title":"QuantumToolbox.triplet_states","text":"triplet_states()\n\nReturn a list of the two particle triplet states: \n\n11rangle\n( 01rangle + 10rangle )  sqrt2\n00rangle\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.w_state","page":"API","title":"QuantumToolbox.w_state","text":"w_state(n::Int)\n\nReturns the n-qubit W-state:\n\nfrac1sqrtn left( 1000rangle + 0100rangle + cdots + 0001rangle right)\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.ghz_state","page":"API","title":"QuantumToolbox.ghz_state","text":"ghz_state(n::Int; d::Int=2)\n\nReturns the generalized n-qudit Greenberger–Horne–Zeilinger (GHZ) state:\n\nfrac1sqrtd sum_i=0^d-1  i rangle otimes cdots otimes  i rangle\n\nHere, d specifies the dimension of each qudit. Default to d=2 (qubit).\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sigmap","page":"API","title":"QuantumToolbox.sigmap","text":"sigmap()\n\nPauli ladder operator hatsigma_+ = hatsigma_x + i hatsigma_y.\n\nSee also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sigmam","page":"API","title":"QuantumToolbox.sigmam","text":"sigmam()\n\nPauli ladder operator hatsigma_- = hatsigma_x - i hatsigma_y.\n\nSee also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sigmax","page":"API","title":"QuantumToolbox.sigmax","text":"sigmax()\n\nPauli operator hatsigma_x = hatsigma_- + hatsigma_+.\n\nSee also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sigmay","page":"API","title":"QuantumToolbox.sigmay","text":"sigmay()\n\nPauli operator hatsigma_y = i left( hatsigma_- - hatsigma_+ right).\n\nSee also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sigmaz","page":"API","title":"QuantumToolbox.sigmaz","text":"sigmaz()\n\nPauli operator hatsigma_z = commhatsigma_+hatsigma_-.\n\nSee also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.jmat","page":"API","title":"QuantumToolbox.jmat","text":"jmat(j::Real, which::Symbol)\n\nGenerate higher-order Spin-j operators, where j is the spin quantum number and can be a non-negative integer or half-integer\n\nThe parameter which specifies which of the following operator to return.\n\n:x: S_x\n:y: S_y\n:z: S_z\n:+: S_+\n:-: S_-\n\nNote that if the parameter which is not specified, returns a set of Spin-j operators: (S_x S_y S_z)\n\nExamples\n\njulia> jmat(0.5, :x)\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true\n2×2 SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      0.5+0.0im\n 0.5+0.0im      ⋅\n\njulia> jmat(0.5, :-)\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=false\n2×2 SparseMatrixCSC{ComplexF64, Int64} with 1 stored entry:\n     ⋅          ⋅    \n 1.0+0.0im      ⋅\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spin_Jx","page":"API","title":"QuantumToolbox.spin_Jx","text":"spin_Jx(j::Real)\n\nS_x operator for Spin-j, where j is the spin quantum number and can be a non-negative integer or half-integer\n\nSee also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spin_Jy","page":"API","title":"QuantumToolbox.spin_Jy","text":"spin_Jy(j::Real)\n\nS_y operator for Spin-j, where j is the spin quantum number and can be a non-negative integer or half-integer\n\nSee also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spin_Jz","page":"API","title":"QuantumToolbox.spin_Jz","text":"spin_Jz(j::Real)\n\nS_z operator for Spin-j, where j is the spin quantum number and can be a non-negative integer or half-integer\n\nSee also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spin_Jm","page":"API","title":"QuantumToolbox.spin_Jm","text":"spin_Jm(j::Real)\n\nS_- operator for Spin-j, where j is the spin quantum number and can be a non-negative integer or half-integer\n\nSee also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spin_Jp","page":"API","title":"QuantumToolbox.spin_Jp","text":"spin_Jp(j::Real)\n\nS_+ operator for Spin-j, where j is the spin quantum number and can be a non-negative integer or half-integer\n\nSee also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spin_J_set","page":"API","title":"QuantumToolbox.spin_J_set","text":"spin_J_set(j::Real)\n\nA set of Spin-j operators (S_x S_y S_z), where j is the spin quantum number and can be a non-negative integer or half-integer\n\nNote that this functions is same as jmat(j). See also jmat.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.destroy","page":"API","title":"QuantumToolbox.destroy","text":"destroy(N::Int)\n\nBosonic annihilation operator with Hilbert space cutoff N. \n\nThis operator acts on a fock state as hata ketn = sqrtn ketn-1.\n\nExamples\n\njulia> a = destroy(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢\n\njulia> fock(20, 3)' * a * fock(20, 4)\n2.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.create","page":"API","title":"QuantumToolbox.create","text":"create(N::Int)\n\nBosonic creation operator with Hilbert space cutoff N.\n\nThis operator acts on a fock state as hata^dagger ketn = sqrtn+1 ketn+1.\n\nExamples\n\njulia> a_d = create(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠢⡀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠈⠢⡀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠈⠢⡀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠈⠢⡀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠈⠢⡀\n\njulia> fock(20, 4)' * a_d * fock(20, 3)\n2.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.displace","page":"API","title":"QuantumToolbox.displace","text":"displace(N::Int, α::Number)\n\nGenerate a displacement operator:\n\nhatD(alpha)=expleft( alpha hata^dagger - alpha^* hata right)\n\nwhere hata is the bosonic annihilation operator, and alpha is the amount of displacement in optical phase space.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.squeeze","page":"API","title":"QuantumToolbox.squeeze","text":"squeeze(N::Int, z::Number)\n\nGenerate a single-mode squeeze operator:\n\nhatS(z)=expleft( frac12 (z^* hata^2 - z(hata^dagger)^2) right)\n\nwhere hata is the bosonic annihilation operator.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.num","page":"API","title":"QuantumToolbox.num","text":"num(N::Int)\n\nBosonic number operator with Hilbert space cutoff N. \n\nThis operator is defined as hatN=hata^dagger hata, where hata is the bosonic annihilation operator.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.position","page":"API","title":"QuantumToolbox.position","text":"position(N::Int)\n\nPosition operator with Hilbert space cutoff N. \n\nThis operator is defined as hatx=frac1sqrt2 (hata^dagger + hata), where hata is the bosonic annihilation operator.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.momentum","page":"API","title":"QuantumToolbox.momentum","text":"momentum(N::Int)\n\nMomentum operator with Hilbert space cutoff N. \n\nThis operator is defined as hatp= fracisqrt2 (hata^dagger - hata), where hata is the bosonic annihilation operator.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.phase","page":"API","title":"QuantumToolbox.phase","text":"phase(N::Int, ϕ0::Real=0)\n\nSingle-mode Pegg-Barnett phase operator with Hilbert space cutoff N and the reference phase phi_0.\n\nThis operator is defined as\n\nhatphi = sum_m=0^N-1 phi_m phi_mrangle langlephi_m\n\nwhere\n\nphi_m = phi_0 + frac2mpiN\n\nand\n\nphi_mrangle = frac1sqrtN sum_n=0^N-1 exp(i n phi_m) nrangle\n\nReference\n\nMichael Martin Nieto, QUANTUM PHASE AND QUANTUM PHASE OPERATORS: Some Physics and Some History, arXiv:hep-th/9304036, Equation (30-32).\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.fdestroy","page":"API","title":"QuantumToolbox.fdestroy","text":"fdestroy(N::Int, j::Int)\n\nConstruct a fermionic destruction operator acting on the j-th site, where the fock space has totally N-sites:\n\nHere, we use the Jordan-Wigner transformation, namely\n\nd_j = sigma_z^otimes j otimes sigma_- otimes I^otimes N-j-1\n\nNote that the site index j should satisfy: 0 ≤ j ≤ N - 1\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.fcreate","page":"API","title":"QuantumToolbox.fcreate","text":"fcreate(N::Int, j::Int)\n\nConstruct a fermionic creation operator acting on the j-th site, where the fock space has totally N-sites:\n\nHere, we use the Jordan-Wigner transformation, namely\n\nd_j^dagger = sigma_z^otimes j otimes sigma_+ otimes I^otimes N-j-1\n\nNote that the site index j should satisfy: 0 ≤ j ≤ N - 1\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.tunneling","page":"API","title":"QuantumToolbox.tunneling","text":"tunneling(N::Int, m::Int=1; sparse::Bool=false)\n\nGenerate a tunneling operator defined as:\n\nsum_n=0^N-m  n ranglelangle n+m  +  n+m ranglelangle n \n\nwhere N is the number of basis states in the Hilbert space, and m is the number of excitations in tunneling event.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.qft","page":"API","title":"QuantumToolbox.qft","text":"qft(dimensions)\n\nGenerates a discrete Fourier transform matrix hatF_N for Quantum Fourier Transform (QFT) with given argument dimensions.\n\nThe dimensions can be either the following types:\n\ndimensions::Int: Number of basis states in the Hilbert space.\ndimensions::Vector{Int}: list of dimensions representing the each number of basis in the subsystems.\n\nN represents the total dimension, and therefore the matrix is defined as\n\nhatF_N = frac1sqrtNbeginbmatrix\n1  1  1  1  cdots  1\n1  omega  omega^2  omega^3  cdots  omega^N-1\n1  omega^2  omega^4  omega^6  cdots  omega^2(N-1)\n1  omega^3  omega^6  omega^9  cdots  omega^3(N-1)\nvdots  vdots  vdots  vdots  ddots  vdots\n1  omega^N-1  omega^2(N-1)  omega^3(N-1)  cdots  omega^(N-1)(N-1)\nendbmatrix\n\nwhere omega = exp(frac2 pi iN).\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.eye","page":"API","title":"QuantumToolbox.eye","text":"eye(N::Int; type=Operator, dims=nothing)\n\nIdentity operator hatmathbb1 with size N.\n\nIt is also possible to specify the list of Hilbert dimensions dims if different subsystems are present.\n\nNote that type can only be either Operator or SuperOperator\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.projection","page":"API","title":"QuantumToolbox.projection","text":"projection(N::Int, i::Int, j::Int)\n\nGenerates the projection operator hatO = dyadij with Hilbert space dimension N.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.commutator","page":"API","title":"QuantumToolbox.commutator","text":"commutator(A::QuantumObject, B::QuantumObject; anti::Bool=false)\n\nReturn the commutator (or anti-commutator) of the two QuantumObject:\n\ncommutator (anti=false): AB-BA\nanticommutator (anti=true): AB+BA\n\nNote that A and B must be Operator\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spre","page":"API","title":"QuantumToolbox.spre","text":"spre(A::QuantumObject, Id_cache=I(size(A,1)))\n\nReturns the SuperOperator form of A acting on the left of the density matrix operator: mathcalO left(hatAright) left hatrho right = hatA hatrho.\n\nSince the density matrix is vectorized in OperatorKet form: hatrhoranglerangle, this SuperOperator is always a matrix hatmathbb1 otimes hatA, namely \n\nmathcalO left(hatAright) left hatrho right = hatmathbb1 otimes hatA  hatrhoranglerangle\n\nThe optional argument Id_cache can be used to pass a precomputed identity matrix. This can be useful when the same function is applied multiple times with a known Hilbert space dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spost","page":"API","title":"QuantumToolbox.spost","text":"spost(B::QuantumObject, Id_cache=I(size(B,1)))\n\nReturns the SuperOperator form of B acting on the right of the density matrix operator: mathcalO left(hatBright) left hatrho right = hatrho hatB.\n\nSince the density matrix is vectorized in OperatorKet form: hatrhoranglerangle, this SuperOperator is always a matrix hatB^T otimes hatmathbb1, namely\n\nmathcalO left(hatBright) left hatrho right = hatB^T otimes hatmathbb1  hatrhoranglerangle\n\nThe optional argument Id_cache can be used to pass a precomputed identity matrix. This can be useful when the same function is applied multiple times with a known Hilbert space dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sprepost","page":"API","title":"QuantumToolbox.sprepost","text":"sprepost(A::QuantumObject, B::QuantumObject)\n\nReturns the SuperOperator form of A and B acting on the left and right of the density matrix operator, respectively: mathcalO left( hatA hatB right) left hatrho right = hatA hatrho hatB.\n\nSince the density matrix is vectorized in OperatorKet form: hatrhoranglerangle, this SuperOperator is always a matrix hatB^T otimes hatA, namely\n\nmathcalO left(hatA hatBright) left hatrho right = hatB^T otimes hatA  hatrhoranglerangle = textrmspre(A) * textrmspost(B)  hatrhoranglerangle\n\nSee also spre and spost.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.lindblad_dissipator","page":"API","title":"QuantumToolbox.lindblad_dissipator","text":"lindblad_dissipator(O::QuantumObject, Id_cache=I(size(O,1))\n\nReturns the Lindblad SuperOperator defined as\n\nmathcalD left( hatO right) left hatrho right = frac12 left( 2 hatO hatrho hatO^dagger - \nhatO^dagger hatO hatrho - hatrho hatO^dagger hatO right)\n\nThe optional argument Id_cache can be used to pass a precomputed identity matrix. This can be useful when the same function is applied multiple times with a known Hilbert space dimension.\n\nSee also spre and spost.\n\n\n\n\n\n","category":"function"},{"location":"api/#doc-API:Synonyms-of-functions-for-Qobj","page":"API","title":"Synonyms of functions for Qobj","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Qobj\nshape\nisherm\ntrans\ndag\nmatrix_element\nunit\nsqrtm\nlogm\nexpm\nsinm\ncosm\ntensor\n⊗\nqeye","category":"page"},{"location":"api/#QuantumToolbox.Qobj","page":"API","title":"QuantumToolbox.Qobj","text":"Qobj(A::AbstractArray; type::QuantumObjectType, dims::Vector{Int})\n\nGenerate QuantumObject\n\nNote that this functions is same as QuantumObject(A; type=type, dims=dims)\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.shape","page":"API","title":"QuantumToolbox.shape","text":"shape(A::QuantumObject)\n\nReturns a tuple containing each dimensions of the array in the QuantumObject.\n\nNote that this function is same as size(A)\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.isherm","page":"API","title":"QuantumToolbox.isherm","text":"isherm(A::QuantumObject)\n\nTest whether the QuantumObject is Hermitian.\n\nNote that this functions is same as ishermitian(A)\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.trans","page":"API","title":"QuantumToolbox.trans","text":"trans(A::QuantumObject)\n\nLazy matrix transpose of the QuantumObject.\n\nNote that this function is same as transpose(A)\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.dag","page":"API","title":"QuantumToolbox.dag","text":"dag(A::QuantumObject)\n\nLazy adjoint (conjugate transposition) of the QuantumObject\n\nNote that this function is same as adjoint(A)\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.matrix_element","page":"API","title":"QuantumToolbox.matrix_element","text":"matrix_element(i::QuantumObject, A::QuantumObject j::QuantumObject)\n\nCompute the generalized dot product dot(i, A*j) between three QuantumObject: langle i  A  j rangle\n\nNote that this function is same as dot(i, A, j)\n\nSupports the following inputs:\n\nA is in the type of Operator, with i and j are both Ket.\nA is in the type of SuperOperator, with i and j are both OperatorKet\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.unit","page":"API","title":"QuantumToolbox.unit","text":"unit(A::QuantumObject, p::Real)\n\nReturn normalized QuantumObject so that its p-norm equals to unity, i.e. norm(A, p) == 1.\n\nSupport for the following types of QuantumObject:\n\nIf A is Ket or Bra, default p = 2\nIf A is Operator, default p = 1\n\nNote that this function is same as normalize(A, p)\n\nAlso, see norm about its definition for different types of QuantumObject.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sqrtm","page":"API","title":"QuantumToolbox.sqrtm","text":"sqrtm(A::QuantumObject)\n\nMatrix square root of Operator type of QuantumObject\n\nNote that for other types of QuantumObject use sprt(A) instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.logm","page":"API","title":"QuantumToolbox.logm","text":"logm(A::QuantumObject)\n\nMatrix logarithm of QuantumObject\n\nNote that this function is same as log(A) and only supports for Operator and SuperOperator\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.expm","page":"API","title":"QuantumToolbox.expm","text":"expm(A::QuantumObject)\n\nMatrix exponential of QuantumObject\n\nNote that this function is same as exp(A) and only supports for Operator and SuperOperator\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sinm","page":"API","title":"QuantumToolbox.sinm","text":"sinm(A::QuantumObject)\n\nMatrix sine of QuantumObject, defined as\n\nsin left( hatA right) = frace^i hatA - e^-i hatA2 i\n\nNote that this function is same as sin(A) and only supports for Operator and SuperOperator\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.cosm","page":"API","title":"QuantumToolbox.cosm","text":"cosm(A::QuantumObject)\n\nMatrix cosine of QuantumObject, defined as\n\ncos left( hatA right) = frace^i hatA + e^-i hatA2\n\nNote that this function is same as cos(A) and only supports for Operator and SuperOperator\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.tensor","page":"API","title":"QuantumToolbox.tensor","text":"tensor(A::QuantumObject, B::QuantumObject, ...)\n\nReturns the Kronecker product hatA otimes hatB otimes cdots.\n\nNote that this function is same as kron(A, B, ...)\n\nExamples\n\njulia> x = sigmax()\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true\n2×2 SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅\n\njulia> x_list = fill(x, 3);\n\njulia> tensor(x_list...)\nQuantum Object:   type=Operator   dims=[2, 2, 2]   size=(8, 8)   ishermitian=true\n8×8 SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:\n     ⋅          ⋅          ⋅      …      ⋅          ⋅      1.0+0.0im\n     ⋅          ⋅          ⋅             ⋅      1.0+0.0im      ⋅\n     ⋅          ⋅          ⋅         1.0+0.0im      ⋅          ⋅\n     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅\n     ⋅          ⋅          ⋅             ⋅          ⋅          ⋅\n     ⋅          ⋅      1.0+0.0im  …      ⋅          ⋅          ⋅\n     ⋅      1.0+0.0im      ⋅             ⋅          ⋅          ⋅\n 1.0+0.0im      ⋅          ⋅             ⋅          ⋅          ⋅\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.:⊗","page":"API","title":"QuantumToolbox.:⊗","text":"⊗(A::QuantumObject, B::QuantumObject)\n\nReturns the Kronecker product hatA otimes hatB.\n\nNote that this function is same as kron(A, B)\n\nExamples\n\njulia> a = destroy(20)\nQuantum Object:   type=Operator   dims=[20]   size=(20, 20)   ishermitian=false\n20×20 SparseMatrixCSC{ComplexF64, Int64} with 19 stored entries:\n⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢\n\njulia> a ⊗ a\nQuantum Object:   type=Operator   dims=[20, 20]   size=(400, 400)   ishermitian=false\n400×400 SparseMatrixCSC{ComplexF64, Int64} with 361 stored entries:\n⠀⠀⠘⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠦\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.qeye","page":"API","title":"QuantumToolbox.qeye","text":"qeye(N::Int; type=Operator, dims=nothing)\n\nIdentity operator hatmathbb1 with size N.\n\nIt is also possible to specify the list of Hilbert dimensions dims if different subsystems are present.\n\nNote that this function is same as eye(N, type=type, dims=dims), and type can only be either Operator or SuperOperator\n\n\n\n\n\n","category":"function"},{"location":"api/#doc-API:Time-evolution","page":"API","title":"Time evolution","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TimeEvolutionSol\nTimeEvolutionMCSol\nsesolveProblem\nmesolveProblem\nlr_mesolveProblem\nmcsolveProblem\nmcsolveEnsembleProblem\nsesolve\nmesolve\nlr_mesolve\nmcsolve\ndfd_mesolve\ndsf_mesolve\ndsf_mcsolve\nliouvillian\nliouvillian_generalized\nsteadystate\nsteadystate_floquet\nSteadyStateODESolver","category":"page"},{"location":"api/#QuantumToolbox.TimeEvolutionSol","page":"API","title":"QuantumToolbox.TimeEvolutionSol","text":"struct TimeEvolutionSol\n\nA structure storing the results and some information from solving time evolution.\n\nFields (Attributes)\n\ntimes::AbstractVector: The time list of the evolution.\nstates::Vector{QuantumObject}: The list of result states.\nexpect::Matrix: The expectation values corresponding to each time point in times.\nretcode: The return code from the solver.\nalg: The algorithm which is used during the solving process.\nabstol::Real: The absolute tolerance which is used during the solving process.\nreltol::Real: The relative tolerance which is used during the solving process.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.TimeEvolutionMCSol","page":"API","title":"QuantumToolbox.TimeEvolutionMCSol","text":"struct TimeEvolutionMCSol\n\nA structure storing the results and some information from solving quantum trajectories of the Monte Carlo wave function time evolution.\n\nFields (Attributes)\n\nn_traj::Int: Number of trajectories\ntimes::AbstractVector: The time list of the evolution in each trajectory.\nstates::Vector{Vector{QuantumObject}}: The list of result states in each trajectory.\nexpect::Matrix: The expectation values (averaging all trajectories) corresponding to each time point in times.\nexpect_all::Array: The expectation values corresponding to each trajectory and each time point in times\njump_times::Vector{Vector{Real}}: The time records of every quantum jump occurred in each trajectory.\njump_which::Vector{Vector{Int}}: The indices of the jump operators in c_ops that describe the corresponding quantum jumps occurred in each trajectory.\nconverged::Bool: Whether the solution is converged or not.\nalg: The algorithm which is used during the solving process.\nabstol::Real: The absolute tolerance which is used during the solving process.\nreltol::Real: The relative tolerance which is used during the solving process.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumToolbox.sesolveProblem","page":"API","title":"QuantumToolbox.sesolveProblem","text":"sesolveProblem(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector;\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5()\n    e_ops::AbstractVector=[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    progress_bar::Bool=true,\n    kwargs...)\n\nGenerates the ODEProblem for the Schrödinger time evolution of a quantum system:\n\nfracpartialpartial t psi(t)rangle = -i hatH psi(t)rangle\n\nArguments\n\nH::QuantumObject: The Hamiltonian of the system hatH.\nψ0::QuantumObject: The initial state of the system psi(0)rangle.\nt_l::AbstractVector: The time list of the evolution.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm: The algorithm used for the time evolution.\ne_ops::AbstractVector: The list of operators to be evaluated during the evolution.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: The time-dependent Hamiltonian of the system. If nothing, the Hamiltonian is time-independent.\nparams::NamedTuple: The parameters of the system.\nprogress_bar::Bool: Whether to show the progress bar.\nkwargs...: The keyword arguments passed to the ODEProblem constructor.\n\nNotes\n\nThe states will be saved depend on the keyword argument saveat in kwargs.\nIf e_ops is specified, the default value of saveat=[t_l[end]] (only save the final state), otherwise, saveat=t_l (saving the states corresponding to t_l). You can also specify e_ops and saveat separately.\nThe default tolerances in kwargs are given as reltol=1e-6 and abstol=1e-8.\nFor more details about alg and extra kwargs, please refer to DifferentialEquations.jl\n\nReturns\n\nprob: The ODEProblem for the Schrödinger time evolution of the system.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mesolveProblem","page":"API","title":"QuantumToolbox.mesolveProblem","text":"mesolveProblem(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector, \n    c_ops::AbstractVector=[];\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::AbstractVector=[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    progress_bar::Bool=true,\n    kwargs...)\n\nGenerates the ODEProblem for the master equation time evolution of an open quantum system:\n\nfracpartial rho(t)partial t = -ihatH rho(t) + sum_n mathcalD(hatC_n) rho(t)\n\nwhere \n\nmathcalD(hatC_n) rho(t) = hatC_n rho(t) hatC_n^dagger - frac12 hatC_n^dagger hatC_n rho(t) - frac12 rho(t) hatC_n^dagger hatC_n\n\nArguments\n\nH::QuantumObject: The Hamiltonian hatH or the Liouvillian of the system.\nψ0::QuantumObject: The initial state of the system.\nt_l::AbstractVector: The time list of the evolution.\nc_ops::AbstractVector=[]: The list of the collapse operators hatC_n_n.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(): The algorithm used for the time evolution.\ne_ops::AbstractVector=[]: The list of the operators for which the expectation values are calculated.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing: The time-dependent Hamiltonian or Liouvillian.\nparams::NamedTuple=NamedTuple(): The parameters of the time evolution.\nprogress_bar::Bool=true: Whether to show the progress bar.\nkwargs...: The keyword arguments for the ODEProblem.\n\nNotes\n\nThe states will be saved depend on the keyword argument saveat in kwargs.\nIf e_ops is specified, the default value of saveat=[t_l[end]] (only save the final state), otherwise, saveat=t_l (saving the states corresponding to t_l). You can also specify e_ops and saveat separately.\nThe default tolerances in kwargs are given as reltol=1e-6 and abstol=1e-8.\nFor more details about alg and extra kwargs, please refer to DifferentialEquations.jl\n\nReturns\n\nprob::ODEProblem: The ODEProblem for the master equation time evolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.lr_mesolveProblem","page":"API","title":"QuantumToolbox.lr_mesolveProblem","text":"lr_mesolveProblem(H, z, B, t_l, c_ops; e_ops=(), f_ops=(), opt=LRMesolveOptions(), kwargs...) where T\nFormulates the ODEproblem for the low-rank time evolution of the system. The function is called by lr_mesolve.\n\nParameters\n----------\nH : QuantumObject\n    The Hamiltonian of the system.\nz : AbstractMatrix{T}\n    The initial z matrix.\nB : AbstractMatrix{T}\n    The initial B matrix.\nt_l : AbstractVector{T}\n    The time steps at which the expectation values and function values are calculated.\nc_ops : AbstractVector{QuantumObject}\n    The jump operators of the system.\ne_ops : Tuple{QuantumObject}\n    The operators whose expectation values are calculated.\nf_ops : Tuple{Function}\n    The functions whose values are calculated.\nopt : LRMesolveOptions\n    The options of the problem.\nkwargs : NamedTuple\n    Additional keyword arguments for the ODEProblem.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mcsolveProblem","page":"API","title":"QuantumToolbox.mcsolveProblem","text":"mcsolveProblem(H::QuantumObject{<:AbstractArray{T1},OperatorQuantumObject},\n    ψ0::QuantumObject{<:AbstractArray{T2},KetQuantumObject},\n    t_l::AbstractVector,\n    c_ops::Vector{QuantumObject{Tc, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[];\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Vector{QuantumObject{Te, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    jump_callback::TJC=ContinuousLindbladJumpCallback(),\n    kwargs...)\n\nGenerates the ODEProblem for a single trajectory of the Monte Carlo wave function time evolution of an open quantum system.\n\nGiven a system Hamiltonian hatH and a list of collapse (jump) operators hatC_n_n, the evolution of the state psi(t)rangle is governed by the Schrodinger equation:\n\nfracpartialpartial t psi(t)rangle= -i hatH_textrmeff psi(t)rangle\n\nwith a non-Hermitian effective Hamiltonian:\n\nhatH_textrmeff = hatH - fraci2 sum_n hatC_n^dagger hatC_n\n\nTo the first-order of the wave function in a small time delta t, the strictly negative non-Hermitian portion in hatH_textrmeff gives rise to a reduction in the norm of the wave function, namely\n\nlangle psi(t+delta t)  psi(t+delta t) rangle = 1 - delta p\n\nwhere \n\ndelta p = delta t sum_n langle psi(t)  hatC_n^dagger hatC_n  psi(t) rangle\n\nis the corresponding quantum jump probability.\n\nIf the environmental measurements register a quantum jump, the wave function undergoes a jump into a state defined by projecting psi(t)rangle using the collapse operator hatC_n corresponding to the measurement, namely\n\n psi(t+delta t) rangle = frachatC_n psi(t)rangle sqrtlangle psi(t)  hatC_n^dagger hatC_n  psi(t) rangle \n\nArguments\n\nH::QuantumObject: Hamiltonian of the system hatH.\nψ0::QuantumObject: Initial state of the system psi(0)rangle.\nt_l::AbstractVector: List of times at which to save the state of the system.\nc_ops::Vector: List of collapse operators hatC_n_n.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm: Algorithm to use for the time evolution.\ne_ops::Vector: List of operators for which to calculate expectation values.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: Time-dependent part of the Hamiltonian.\nparams::NamedTuple: Dictionary of parameters to pass to the solver.\nseeds::Union{Nothing, Vector{Int}}: List of seeds for the random number generator. Length must be equal to the number of trajectories provided.\njump_callback::LindbladJumpCallbackType: The Jump Callback type: Discrete or Continuous.\nkwargs...: Additional keyword arguments to pass to the solver.\n\nNotes\n\nThe states will be saved depend on the keyword argument saveat in kwargs.\nIf e_ops is specified, the default value of saveat=[t_l[end]] (only save the final state), otherwise, saveat=t_l (saving the states corresponding to t_l). You can also specify e_ops and saveat separately.\nThe default tolerances in kwargs are given as reltol=1e-6 and abstol=1e-8.\nFor more details about alg and extra kwargs, please refer to DifferentialEquations.jl\n\nReturns\n\nprob::ODEProblem: The ODEProblem for the Monte Carlo wave function time evolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mcsolveEnsembleProblem","page":"API","title":"QuantumToolbox.mcsolveEnsembleProblem","text":"mcsolveEnsembleProblem(H::QuantumObject{<:AbstractArray{T1},OperatorQuantumObject},\n    ψ0::QuantumObject{<:AbstractArray{T2},KetQuantumObject},\n    t_l::AbstractVector,\n    c_ops::Vector{QuantumObject{Tc, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[];\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Vector{QuantumObject{Te, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    jump_callback::TJC=ContinuousLindbladJumpCallback(),\n    prob_func::Function=_mcsolve_prob_func,\n    output_func::Function=_mcsolve_output_func,\n    kwargs...)\n\nGenerates the EnsembleProblem of ODEProblems for the ensemble of trajectories of the Monte Carlo wave function time evolution of an open quantum system.\n\nGiven a system Hamiltonian hatH and a list of collapse (jump) operators hatC_n_n, the evolution of the state psi(t)rangle is governed by the Schrodinger equation:\n\nfracpartialpartial t psi(t)rangle= -i hatH_textrmeff psi(t)rangle\n\nwith a non-Hermitian effective Hamiltonian:\n\nhatH_textrmeff = hatH - fraci2 sum_n hatC_n^dagger hatC_n\n\nTo the first-order of the wave function in a small time delta t, the strictly negative non-Hermitian portion in hatH_textrmeff gives rise to a reduction in the norm of the wave function, namely\n\nlangle psi(t+delta t)  psi(t+delta t) rangle = 1 - delta p\n\nwhere \n\ndelta p = delta t sum_n langle psi(t)  hatC_n^dagger hatC_n  psi(t) rangle\n\nis the corresponding quantum jump probability.\n\nIf the environmental measurements register a quantum jump, the wave function undergoes a jump into a state defined by projecting psi(t)rangle using the collapse operator hatC_n corresponding to the measurement, namely\n\n psi(t+delta t) rangle = frachatC_n psi(t)rangle sqrtlangle psi(t)  hatC_n^dagger hatC_n  psi(t) rangle \n\nArguments\n\nH::QuantumObject: Hamiltonian of the system hatH.\nψ0::QuantumObject: Initial state of the system psi(0)rangle.\nt_l::AbstractVector: List of times at which to save the state of the system.\nc_ops::Vector: List of collapse operators hatC_n_n.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm: Algorithm to use for the time evolution.\ne_ops::Vector: List of operators for which to calculate expectation values.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: Time-dependent part of the Hamiltonian.\nparams::NamedTuple: Dictionary of parameters to pass to the solver.\nseeds::Union{Nothing, Vector{Int}}: List of seeds for the random number generator. Length must be equal to the number of trajectories provided.\njump_callback::LindbladJumpCallbackType: The Jump Callback type: Discrete or Continuous.\nprob_func::Function: Function to use for generating the ODEProblem.\noutput_func::Function: Function to use for generating the output of a single trajectory.\nkwargs...: Additional keyword arguments to pass to the solver.\n\nNotes\n\nThe states will be saved depend on the keyword argument saveat in kwargs.\nIf e_ops is specified, the default value of saveat=[t_l[end]] (only save the final state), otherwise, saveat=t_l (saving the states corresponding to t_l). You can also specify e_ops and saveat separately.\nThe default tolerances in kwargs are given as reltol=1e-6 and abstol=1e-8.\nFor more details about alg and extra kwargs, please refer to DifferentialEquations.jl\n\nReturns\n\nprob::EnsembleProblem with ODEProblem: The Ensemble ODEProblem for the Monte Carlo wave function time evolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.sesolve","page":"API","title":"QuantumToolbox.sesolve","text":"sesolve(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector;\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::AbstractVector=[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    progress_bar::Bool=true,\n    kwargs...)\n\nTime evolution of a closed quantum system using the Schrödinger equation:\n\nfracpartialpartial t psi(t)rangle = -i hatH psi(t)rangle\n\nArguments\n\nH::QuantumObject: The Hamiltonian of the system hatH.\nψ0::QuantumObject: The initial state of the system psi(0)rangle.\nt_l::AbstractVector: List of times at which to save the state of the system.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm: Algorithm to use for the time evolution.\ne_ops::AbstractVector: List of operators for which to calculate expectation values.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: Time-dependent part of the Hamiltonian.\nparams::NamedTuple: Dictionary of parameters to pass to the solver.\nprogress_bar::Bool: Whether to show the progress bar.\nkwargs...: Additional keyword arguments to pass to the solver.\n\nNotes\n\nThe states will be saved depend on the keyword argument saveat in kwargs.\nIf e_ops is specified, the default value of saveat=[t_l[end]] (only save the final state), otherwise, saveat=t_l (saving the states corresponding to t_l). You can also specify e_ops and saveat separately.\nThe default tolerances in kwargs are given as reltol=1e-6 and abstol=1e-8.\nFor more details about alg and extra kwargs, please refer to DifferentialEquations.jl\n\nReturns\n\nsol::TimeEvolutionSol: The solution of the time evolution. See also TimeEvolutionSol\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mesolve","page":"API","title":"QuantumToolbox.mesolve","text":"mesolve(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector, \n    c_ops::AbstractVector=[];\n    alg::OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::AbstractVector=[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    progress_bar::Bool=true,\n    kwargs...)\n\nTime evolution of an open quantum system using Lindblad master equation:\n\nfracpartial rho(t)partial t = -ihatH rho(t) + sum_n mathcalD(hatC_n) rho(t)\n\nwhere \n\nmathcalD(hatC_n) rho(t) = hatC_n rho(t) hatC_n^dagger - frac12 hatC_n^dagger hatC_n rho(t) - frac12 rho(t) hatC_n^dagger hatC_n\n\nArguments\n\nH::QuantumObject: The Hamiltonian hatH or the Liouvillian of the system.\nψ0::QuantumObject: The initial state of the system.\nt_l::AbstractVector: The time list of the evolution.\nc_ops::AbstractVector=[]: The list of the collapse operators hatC_n_n.\nalg::OrdinaryDiffEqAlgorithm: Algorithm to use for the time evolution.\ne_ops::AbstractVector: List of operators for which to calculate expectation values.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: Time-dependent part of the Hamiltonian.\nparams::NamedTuple: Named Tuple of parameters to pass to the solver.\nprogress_bar::Bool: Whether to show the progress bar.\nkwargs...: Additional keyword arguments to pass to the solver.\n\nNotes\n\nThe states will be saved depend on the keyword argument saveat in kwargs.\nIf e_ops is specified, the default value of saveat=[t_l[end]] (only save the final state), otherwise, saveat=t_l (saving the states corresponding to t_l). You can also specify e_ops and saveat separately.\nThe default tolerances in kwargs are given as reltol=1e-6 and abstol=1e-8.\nFor more details about alg and extra kwargs, please refer to DifferentialEquations.jl\n\nReturns\n\nsol::TimeEvolutionSol: The solution of the time evolution. See also TimeEvolutionSol\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.lr_mesolve","page":"API","title":"QuantumToolbox.lr_mesolve","text":"lr_mesolve(prob::ODEProblem; kwargs...)\nSolves the ODEProblem formulated by lr_mesolveProblem. The function is called by lr_mesolve.\n\nParameters\n----------\nprob : ODEProblem\n    The ODEProblem formulated by lr_mesolveProblem.\nkwargs : NamedTuple\n    Additional keyword arguments for the ODEProblem.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.mcsolve","page":"API","title":"QuantumToolbox.mcsolve","text":"mcsolve(H::QuantumObject{<:AbstractArray{T1},OperatorQuantumObject},\n    ψ0::QuantumObject{<:AbstractArray{T2},KetQuantumObject},\n    t_l::AbstractVector,\n    c_ops::Vector{QuantumObject{Tc, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[];\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Vector{QuantumObject{Te, OperatorQuantumObject}}=QuantumObject{Matrix, OperatorQuantumObject}[],\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    n_traj::Int=1,\n    ensemble_method=EnsembleThreads(),\n    jump_callback::TJC=ContinuousLindbladJumpCallback(),\n    kwargs...)\n\nTime evolution of an open quantum system using quantum trajectories.\n\nGiven a system Hamiltonian hatH and a list of collapse (jump) operators hatC_n_n, the evolution of the state psi(t)rangle is governed by the Schrodinger equation:\n\nfracpartialpartial t psi(t)rangle= -i hatH_textrmeff psi(t)rangle\n\nwith a non-Hermitian effective Hamiltonian:\n\nhatH_textrmeff = hatH - fraci2 sum_n hatC_n^dagger hatC_n\n\nTo the first-order of the wave function in a small time delta t, the strictly negative non-Hermitian portion in hatH_textrmeff gives rise to a reduction in the norm of the wave function, namely\n\nlangle psi(t+delta t)  psi(t+delta t) rangle = 1 - delta p\n\nwhere \n\ndelta p = delta t sum_n langle psi(t)  hatC_n^dagger hatC_n  psi(t) rangle\n\nis the corresponding quantum jump probability.\n\nIf the environmental measurements register a quantum jump, the wave function undergoes a jump into a state defined by projecting psi(t)rangle using the collapse operator hatC_n corresponding to the measurement, namely\n\n psi(t+delta t) rangle = frachatC_n psi(t)rangle sqrtlangle psi(t)  hatC_n^dagger hatC_n  psi(t) rangle \n\nArguments\n\nH::QuantumObject: Hamiltonian of the system hatH.\nψ0::QuantumObject: Initial state of the system psi(0)rangle.\nt_l::AbstractVector: List of times at which to save the state of the system.\nc_ops::Vector: List of collapse operators hatC_n_n.\nalg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm: Algorithm to use for the time evolution.\ne_ops::Vector: List of operators for which to calculate expectation values.\nH_t::Union{Nothing,Function,TimeDependentOperatorSum}: Time-dependent part of the Hamiltonian.\nparams::NamedTuple: Dictionary of parameters to pass to the solver.\nseeds::Union{Nothing, Vector{Int}}: List of seeds for the random number generator. Length must be equal to the number of trajectories provided.\nn_traj::Int: Number of trajectories to use.\nensemble_method: Ensemble method to use.\njump_callback::LindbladJumpCallbackType: The Jump Callback type: Discrete or Continuous.\nprob_func::Function: Function to use for generating the ODEProblem.\noutput_func::Function: Function to use for generating the output of a single trajectory.\nkwargs...: Additional keyword arguments to pass to the solver.\n\nNotes\n\nensemble_method can be one of EnsembleThreads(), EnsembleSerial(), EnsembleDistributed()\nThe states will be saved depend on the keyword argument saveat in kwargs.\nIf e_ops is specified, the default value of saveat=[t_l[end]] (only save the final state), otherwise, saveat=t_l (saving the states corresponding to t_l). You can also specify e_ops and saveat separately.\nThe default tolerances in kwargs are given as reltol=1e-6 and abstol=1e-8.\nFor more details about alg and extra kwargs, please refer to DifferentialEquations.jl\n\nReturns\n\nsol::TimeEvolutionMCSol: The solution of the time evolution. See also TimeEvolutionMCSol\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.dfd_mesolve","page":"API","title":"QuantumToolbox.dfd_mesolve","text":"dfd_mesolve(H::Function, ψ0::QuantumObject,\n    t_l::AbstractVector, c_ops::Function, maxdims::AbstractVector,\n    dfd_params::NamedTuple=NamedTuple();\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Function=(dim_list) -> Vector{Vector{T1}}([]),\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    tol_list::Vector{<:Number}=fill(1e-8, length(maxdims)),\n    kwargs...)\n\nTime evolution of an open quantum system using master equation, dynamically changing the dimension of the Hilbert subspaces.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.dsf_mesolve","page":"API","title":"QuantumToolbox.dsf_mesolve","text":"dsf_mesolve(H::Function,\n    ψ0::QuantumObject,\n    t_l::AbstractVector, c_ops::Function,\n    op_list::Vector{TOl},\n    α0_l::Vector{<:Number}=zeros(length(op_list)),\n    dsf_params::NamedTuple=NamedTuple();\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Function=(op_list,p) -> Vector{TOl}([]),\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    δα_list::Vector{<:Number}=fill(0.2, length(op_list)),\n    krylov_dim::Int=max(6, min(10, cld(length(ket2dm(ψ0).data), 4))),\n    kwargs...)\n\nTime evolution of an open quantum system using master equation and the Dynamical Shifted Fock algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.dsf_mcsolve","page":"API","title":"QuantumToolbox.dsf_mcsolve","text":"dsf_mcsolve(H::Function,\n    ψ0::QuantumObject,\n    t_l::AbstractVector, c_ops::Function,\n    op_list::Vector{TOl},\n    α0_l::Vector{<:Number}=zeros(length(op_list)),\n    dsf_params::NamedTuple=NamedTuple();\n    alg::OrdinaryDiffEq.OrdinaryDiffEqAlgorithm=Tsit5(),\n    e_ops::Function=(op_list,p) -> Vector{TOl}([]),\n    H_t::Union{Nothing,Function,TimeDependentOperatorSum}=nothing,\n    params::NamedTuple=NamedTuple(),\n    δα_list::Vector{<:Real}=fill(0.2, length(op_list)),\n    n_traj::Int=1,\n    ensemble_method=EnsembleThreads(),\n    jump_callback::LindbladJumpCallbackType=ContinuousLindbladJumpCallback(),\n    krylov_dim::Int=max(6, min(10, cld(length(ket2dm(ψ0).data), 4))),\n    kwargs...)\n\nTime evolution of a quantum system using the Monte Carlo wave function method and the Dynamical Shifted Fock algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.liouvillian","page":"API","title":"QuantumToolbox.liouvillian","text":"liouvillian(H::QuantumObject, c_ops::AbstractVector, Id_cache=I(prod(H.dims)))\n\nConstruct the Liouvillian SuperOperator for a system Hamiltonian hatH and a set of collapse operators hatC_n_n:\n\nmathcalL cdot = -ihatH cdot + sum_n mathcalD(hatC_n) cdot\n\nwhere \n\nmathcalD(hatC_n) cdot = hatC_n cdot hatC_n^dagger - frac12 hatC_n^dagger hatC_n cdot - frac12 cdot hatC_n^dagger hatC_n\n\nThe optional argument Id_cache can be used to pass a precomputed identity matrix. This can be useful when the same function is applied multiple times with a known Hilbert space dimension.\n\nSee also spre, spost, and lindblad_dissipator.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.liouvillian_generalized","page":"API","title":"QuantumToolbox.liouvillian_generalized","text":"liouvillian_generalized(H::QuantumObject, fields::Vector, \nT_list::Vector; N_trunc::Int=size(H,1), tol::Float64=0.0, σ_filter::Union{Nothing, Real}=nothing)\n\nConstructs the generalized Liouvillian for a system coupled to a bath of harmonic oscillators.\n\nSee, e.g., Settineri, Alessio, et al. \"Dissipation and thermal noise in hybrid quantum systems in the ultrastrong-coupling regime.\" Physical Review A 98.5 (2018): 053834.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.steadystate","page":"API","title":"QuantumToolbox.steadystate","text":"steadystate(\n    H::QuantumObject{MT1,HOpType},\n    ψ0::QuantumObject{<:AbstractArray{T2},StateOpType},\n    tspan::Real = Inf,\n    c_ops::Vector{QuantumObject{Tc,COpType}} = QuantumObject{MT1,HOpType}[];\n    solver::SteadyStateODESolver = SteadyStateODESolver(),\n    reltol::Real = 1.0e-8,\n    abstol::Real = 1.0e-10,\n    kwargs...,\n)\n\nSolve the stationary state based on time evolution (ordinary differential equations; OrdinaryDiffEq.jl) with a given initial state.\n\nThe termination condition of the stationary state rhoranglerangle is that either the following condition is true:\n\nlVertfracpartial rhorangleranglepartial trVert leq textrmreltol timeslVertfracpartial rhorangleranglepartial t+rhorangleranglerVert\n\nor\n\nlVertfracpartial rhorangleranglepartial trVert leq textrmabstol\n\nParameters\n\nH::QuantumObject: The Hamiltonian or the Liouvillian of the system.\nψ0::QuantumObject: The initial state of the system.\ntspan::Real=Inf: The final time step for the steady state problem.\nc_ops::AbstractVector=[]: The list of the collapse operators.\nsolver::SteadyStateODESolver=SteadyStateODESolver(): see SteadyStateODESolver for more details.\nreltol::Real=1.0e-8: Relative tolerance in steady state terminate condition and solver adaptive timestepping.\nabstol::Real=1.0e-10: Absolute tolerance in steady state terminate condition and solver adaptive timestepping.\nkwargs...: The keyword arguments for the ODEProblem.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.steadystate_floquet","page":"API","title":"QuantumToolbox.steadystate_floquet","text":"steadystate_floquet(\n    H_0::QuantumObject{MT,OpType1},\n    H_p::QuantumObject{<:AbstractArray,OpType2},\n    H_m::QuantumObject{<:AbstractArray,OpType3},\n    ωd::Number,\n    c_ops::AbstractVector = QuantumObject{MT,OpType1}[];\n    n_max::Integer = 2,\n    tol::R = 1e-8,\n    solver::FSolver = SSFloquetLinearSystem,\n    kwargs...,\n)\n\nCalculates the steady state of a periodically driven system. Here H_0 is the Hamiltonian or the Liouvillian of the undriven system. Considering a monochromatic drive at frequency omega_d, we divide it into two parts, H_p and H_m, where H_p oscillates as e^i omega t and H_m oscillates as e^-i omega t. There are two solvers available for this function:\n\nSSFloquetLinearSystem: Solves the linear system of equations.\nSSFloquetEffectiveLiouvillian: Solves the effective Liouvillian.\n\nFor both cases, n_max is the number of Fourier components to consider, and tol is the tolerance for the solver.\n\nIn the case of SSFloquetLinearSystem, the full linear system is solved at once:\n\n( mathcalL_0 - i n omega_d ) hatrho_n + mathcalL_1 hatrho_n-1 + mathcalL_-1 hatrho_n+1 = 0\n\nThis is a tridiagonal linear system of the form\n\nmathbfA cdot mathbfb = 0\n\nwhere\n\nmathbfA = beginpmatrix\nmathcalL_0 - i (-n_textrmmax) omega_textrmd  mathcalL_-1  0  cdots  0 \nmathcalL_1  mathcalL_0 - i (-n_textrmmax+1) omega_textrmd  mathcalL_-1  cdots  0 \n0  mathcalL_1  mathcalL_0 - i (-n_textrmmax+2) omega_textrmd  cdots  0 \nvdots  vdots  vdots  ddots  vdots \n0  0  0  cdots  mathcalL_0 - i n_textrmmax omega_textrmd\nendpmatrix\n\nand\n\nmathbfb = beginpmatrix\nhatrho_-n_textrmmax \nhatrho_-n_textrmmax+1 \nvdots \nhatrho_0 \nvdots \nhatrho_n_textrmmax-1 \nhatrho_n_textrmmax\nendpmatrix\n\nThis will allow to simultaneously obtain all the hatrho_n.\n\nIn the case of SSFloquetEffectiveLiouvillian, instead, the effective Liouvillian is calculated using the matrix continued fraction method.\n\nnote: different return\nThe two solvers returns different objects. The SSFloquetLinearSystem returns a list of QuantumObject, containing the density matrices for each Fourier component (hatrho_-n, with n from 0 to n_textrmmax), while the SSFloquetEffectiveLiouvillian returns only hatrho_0. \n\nArguments\n\nH_0::QuantumObject: The Hamiltonian or the Liouvillian of the undriven system.\nH_p::QuantumObject: The Hamiltonian or the Liouvillian of the part of the drive that oscillates as e^i omega t.\nH_m::QuantumObject: The Hamiltonian or the Liouvillian of the part of the drive that oscillates as e^-i omega t.\nωd::Number: The frequency of the drive.\nc_ops::AbstractVector = QuantumObject: The optional collapse operators.\nn_max::Integer = 2: The number of Fourier components to consider.\ntol::R = 1e-8: The tolerance for the solver.\nsolver::FSolver = SSFloquetLinearSystem: The solver to use.\nkwargs...: Additional keyword arguments to be passed to the solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.SteadyStateODESolver","page":"API","title":"QuantumToolbox.SteadyStateODESolver","text":"SteadyStateODESolver{::OrdinaryDiffEqAlgorithm}\n\nA structure representing an ordinary differential equation (ODE) solver for solving steadystate\n\nIt includes a field (attribute) SteadyStateODESolver.alg that specifies the solving algorithm. Default to Tsit5().\n\nFor more details about the solvers, please refer to DifferentialEquations.jl\n\n\n\n\n\n","category":"type"},{"location":"api/#doc-API:Correlations-and-Spectrum","page":"API","title":"Correlations and Spectrum","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"correlation_3op_2t\ncorrelation_2op_2t\ncorrelation_2op_1t\nspectrum","category":"page"},{"location":"api/#QuantumToolbox.correlation_3op_2t","page":"API","title":"QuantumToolbox.correlation_3op_2t","text":"correlation_3op_2t(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector,\n    τ_l::AbstractVector,\n    A::QuantumObject,\n    B::QuantumObject,\n    C::QuantumObject,\n    c_ops::AbstractVector=[];\n    kwargs...)\n\nReturns the two-times correlation function of three operators hatA, hatB and hatC: expvalhatA(t) hatB(t + tau) hatC(t)\n\nfor a given initial state ketpsi_0.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.correlation_2op_2t","page":"API","title":"QuantumToolbox.correlation_2op_2t","text":"correlation_2op_2t(H::QuantumObject,\n    ψ0::QuantumObject,\n    t_l::AbstractVector,\n    τ_l::AbstractVector,\n    A::QuantumObject,\n    B::QuantumObject,\n    c_ops::AbstractVector=[];\n    reverse::Bool=false,\n    kwargs...)\n\nReturns the two-times correlation function of two operators hatA and hatB  at different times: expvalhatA(t + tau) hatB(t).\n\nWhen reverse=true, the correlation function is calculated as expvalhatA(t) hatB(t + tau).\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.correlation_2op_1t","page":"API","title":"QuantumToolbox.correlation_2op_1t","text":"correlation_2op_1t(H::QuantumObject,\n    ψ0::QuantumObject,\n    τ_l::AbstractVector,\n    A::QuantumObject,\n    B::QuantumObject,\n    c_ops::AbstractVector=[];\n    reverse::Bool=false,\n    kwargs...)\n\nReturns the one-time correlation function of two operators hatA and hatB at different times expvalhatA(tau) hatB(0).\n\nWhen reverse=true, the correlation function is calculated as expvalhatA(0) hatB(tau).\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.spectrum","page":"API","title":"QuantumToolbox.spectrum","text":"spectrum(H::QuantumObject,\n    ω_list::AbstractVector,\n    A::QuantumObject{<:AbstractArray{T2},OperatorQuantumObject},\n    B::QuantumObject{<:AbstractArray{T3},OperatorQuantumObject},\n    c_ops::AbstractVector=[];\n    solver::MySolver=ExponentialSeries(),\n    kwargs...)\n\nReturns the emission spectrum \n\nS(omega) = int_-infty^infty expvalhatA(tau) hatB(0) e^-i omega tau d tau\n\n\n\n\n\n","category":"function"},{"location":"api/#doc-API:Metrics","page":"API","title":"Metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"entropy_vn\nentanglement\ntracedist\nfidelity","category":"page"},{"location":"api/#QuantumToolbox.entropy_vn","page":"API","title":"QuantumToolbox.entropy_vn","text":"entropy_vn(ρ::QuantumObject; base::Int=0, tol::Real=1e-15)\n\nCalculates the Von Neumann entropy S = - Tr left hatrho log left( hatrho right) right where hatrho is the density matrix of the system.\n\nThe base parameter specifies the base of the logarithm to use, and when using the default value 0, the natural logarithm is used. The tol parameter describes the absolute tolerance for detecting the zero-valued eigenvalues of the density matrix hatrho.\n\nExamples\n\nPure state:\n\njulia> ψ = fock(2,0)\nQuantum Object:   type=Ket   dims=[2]   size=(2,)\n2-element Vector{ComplexF64}:\n 1.0 + 0.0im\n 0.0 + 0.0im\n\njulia> ρ = ket2dm(ψ)\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im\n\njulia> entropy_vn(ρ, base=2)\n-0.0\n\nMixed state:\n\njulia> ρ = maximally_mixed_dm(2)\nQuantum Object:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true\n2×2 Diagonal{ComplexF64, Vector{ComplexF64}}:\n 0.5-0.0im      ⋅    \n     ⋅      0.5-0.0im\n\njulia> entropy_vn(ρ, base=2)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.entanglement","page":"API","title":"QuantumToolbox.entanglement","text":"entanglement(QO::QuantumObject, sel::Vector)\n\nCalculates the entanglement by doing the partial trace of QO, selecting only the dimensions with the indices contained in the sel vector, and then using the Von Neumann entropy entropy_vn.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.tracedist","page":"API","title":"QuantumToolbox.tracedist","text":"tracedist(ρ::QuantumObject, σ::QuantumObject)\n\nCalculates the trace distance between two QuantumObject: T(rho sigma) = frac12 lVert rho - sigma rVert_1\n\nNote that ρ and σ must be either Ket or Operator.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.fidelity","page":"API","title":"QuantumToolbox.fidelity","text":"fidelity(ρ::QuantumObject, σ::QuantumObject)\n\nCalculate the fidelity of two QuantumObject: F(rho sigma) = textrmTr sqrtsqrtrho sigma sqrtrho\n\nHere, the definition is from Nielsen & Chuang, \"Quantum Computation and Quantum Information\". It is the square root of the fidelity defined in R. Jozsa, Journal of Modern Optics, 41:12, 2315 (1994).\n\nNote that ρ and σ must be either Ket or Operator.\n\n\n\n\n\n","category":"function"},{"location":"api/#doc-API:Miscellaneous","page":"API","title":"Miscellaneous","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"wigner\nnegativity","category":"page"},{"location":"api/#QuantumToolbox.wigner","page":"API","title":"QuantumToolbox.wigner","text":"wigner(state::QuantumObject, xvec::AbstractVector, yvec::AbstractVector; g::Real=√2,\n    solver::WignerSolver=WignerLaguerre())\n\nGenerates the Wigner quasipropability distribution of state at points xvec + 1im * yvec. The g parameter is a scaling factor related to the value of hbar in the commutation relation x y = i hbar via hbar=2g^2 giving the default value hbar=1.\n\nThe solver parameter can be either WignerLaguerre() or WignerClenshaw(). The former uses the Laguerre polynomial expansion of the Wigner function, while the latter uses the Clenshaw algorithm. The Laguerre expansion is faster for sparse matrices, while the Clenshaw algorithm is faster for dense matrices. The WignerLaguerre solver has an optional parallel parameter which defaults to true and uses multithreading to speed up the calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.negativity","page":"API","title":"QuantumToolbox.negativity","text":"negativity(ρ::QuantumObject, subsys::Int; logarithmic::Bool=false)\n\nCompute the negativity N(rho) = fracVert rho^GammaVert_1 - 12   where rho^Gamma is the partial transpose of rho with respect to the subsystem,   and Vert X Vert_1=textrmTrsqrtX^dagger X is the trace norm.\n\nArguments\n\nρ::QuantumObject: The density matrix (ρ.type must be OperatorQuantumObject).\nsubsys::Int: an index that indicates which subsystem to compute the negativity for.\nlogarithmic::Bool: choose whether to calculate logarithmic negativity or not. Default as false\n\nReturns\n\nN::Real: The value of negativity.\n\nExamples\n\njulia> Ψ = bell_state(0, 0)\nQuantum Object:   type=Ket   dims=[2, 2]   size=(4,)\n4-element Vector{ComplexF64}:\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n\njulia> ρ = ket2dm(Ψ)\nQuantum Object:   type=Operator   dims=[2, 2]   size=(4, 4)   ishermitian=true\n4×4 Matrix{ComplexF64}:\n 0.5+0.0im  0.0+0.0im  0.0+0.0im  0.5+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.5+0.0im  0.0+0.0im  0.0+0.0im  0.5+0.0im\n\njulia> negativity(ρ, 2)\n0.4999999999999998\n\n\n\n\n\n","category":"function"},{"location":"api/#doc-API:Utility-functions","page":"API","title":"Utility functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"QuantumToolbox.versioninfo\nQuantumToolbox.about\ngaussian\nn_th\nrow_major_reshape\nmeshgrid\n_calculate_expectation!\n_adjM_condition_variational\n_adjM_affect!\n_adjM_condition_ratio\n_pinv!\ndBdz!","category":"page"},{"location":"api/#QuantumToolbox.versioninfo","page":"API","title":"QuantumToolbox.versioninfo","text":"QuantumToolbox.versioninfo(io::IO=stdout)\n\nCommand line output of information on QuantumToolbox, dependencies, and system information, same as QuantumToolbox.about.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.about","page":"API","title":"QuantumToolbox.about","text":"QuantumToolbox.about(io::IO=stdout)\n\nCommand line output of information on QuantumToolbox, dependencies, and system information, same as QuantumToolbox.versioninfo.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.gaussian","page":"API","title":"QuantumToolbox.gaussian","text":"gaussian(x::Number, μ::Number, σ::Number)\n\nReturns the gaussian function exp left- frac(x - mu)^22 sigma^2 right, where mu and sigma^2 are the mean and the variance respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.n_th","page":"API","title":"QuantumToolbox.n_th","text":"n_th(ω::Number, T::Real)\n\nGives the mean number of excitations in a mode with frequency ω at temperature T: n_rm th (omega T) = frac1e^omegaT - 1\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.row_major_reshape","page":"API","title":"QuantumToolbox.row_major_reshape","text":"row_major_reshape(Q::AbstractArray, shapes...)\n\nReshapes Q in the row-major order, as numpy.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.meshgrid","page":"API","title":"QuantumToolbox.meshgrid","text":"meshgrid(x::AbstractVector, y::AbstractVector)\n\nEquivalent to numpy meshgrid.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox._calculate_expectation!","page":"API","title":"QuantumToolbox._calculate_expectation!","text":"_calculate_expectation!(p,z,B,idx) where T\nCalculates the expectation values and function values of the operators and functions in p.e_ops and p.f_ops, respectively, and stores them in p.expvals and p.funvals.\nThe function is called by the callback _save_affect_lr_mesolve!.\n\nParameters\n----------\np : NamedTuple\n    The parameters of the problem.\nz : AbstractMatrix{T}\n    The z matrix.\nB : AbstractMatrix{T}\n    The B matrix.\nidx : Integer\n    The index of the current time step.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox._adjM_condition_variational","page":"API","title":"QuantumToolbox._adjM_condition_variational","text":"_adjM_condition_variational(u, t, integrator) where T\nCondition for the dynamical rank adjustment based on the leakage out of the low-rank manifold.\n\nParameters\n----------\nu : AbstractVector{T}\n    The current state of the system.\nt : Real\n    The current time.\nintegrator : ODEIntegrator\n    The integrator of the problem.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox._adjM_affect!","page":"API","title":"QuantumToolbox._adjM_affect!","text":"_adjM_affect!(integrator)\nAffect function for the dynamical rank adjustment. It increases the rank of the low-rank manifold by one, and updates the matrices accordingly.\nIf Δt>0, it rewinds the integrator to the previous time step.\n\nParameters\n----------\nintegrator : ODEIntegrator\n    The integrator of the problem.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox._adjM_condition_ratio","page":"API","title":"QuantumToolbox._adjM_condition_ratio","text":"_adjM_condition_ratio(u, t, integrator) where T\nCondition for the dynamical rank adjustment based on the ratio between the smallest and largest eigenvalues of the density matrix.\nThe spectrum of the density matrix is calculated efficiently using the properties of the SVD decomposition of the matrix.\n\nParameters\n----------\nu : AbstractVector{T}\n    The current state of the system.\nt : Real\n    The current time.\nintegrator : ODEIntegrator\n    The integrator of the problem.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox._pinv!","page":"API","title":"QuantumToolbox._pinv!","text":"_pinv!(A, T1, T2; atol::Real=0.0, rtol::Real=(eps(real(float(oneunit(T))))*min(size(A)...))*iszero(atol)) where T\nComputes the pseudo-inverse of a matrix A, and stores it in T1. If T2 is provided, it is used as a temporary matrix. \nThe algorithm is based on the SVD decomposition of A, and is taken from the Julia package LinearAlgebra.\nThe difference with respect to the original function is that the cutoff is done with a smooth function instead of a step function.\n\nParameters\n----------\nA : AbstractMatrix{T}\n    The matrix to be inverted.\nT1 : AbstractMatrix{T}\nT2 : AbstractMatrix{T}\n    Temporary matrices used in the calculation.\natol : Real\n    Absolute tolerance for the calculation of the pseudo-inverse.   \nrtol : Real\n    Relative tolerance for the calculation of the pseudo-inverse.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumToolbox.dBdz!","page":"API","title":"QuantumToolbox.dBdz!","text":"dBdz!(du, u, p, t) where T\nDynamical evolution equations for the low-rank manifold. The function is called by the ODEProblem.\n\nParameters\n----------\ndu : AbstractVector{T}\n    The derivative of the state of the system.\nu : AbstractVector{T}\n    The current state of the system.\np : NamedTuple\n    The parameters of the problem.\nt : Real\n    The current time.\n\n\n\n\n\n","category":"function"},{"location":"users_guide/QuantumObject/QuantumObject/#doc:Qobj","page":"Quantum Objects (Qobj)","title":"Quantum Objects (Qobj)","text":"","category":"section"},{"location":"users_guide/QuantumObject/QuantumObject/","page":"Quantum Objects (Qobj)","title":"Quantum Objects (Qobj)","text":"This page is still under construction, please visit API first.","category":"page"},{"location":"tutorials/logo/#doc-tutor:Create-QuantumToolbox.jl-logo","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"","category":"section"},{"location":"tutorials/logo/#Introduction","page":"Create QuantumToolbox.jl logo","title":"Introduction","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"In this tutorial, we will demonstrate how to create the logo for the QuantumToolbox.jl package. The logo represents the Wigner function of the triangular cat state, which is a linear superposition of three coherent states. The resulting Wigner function has a triangular shape that resembles the Julia logo. We will also define a custom colormap that varies based on the value of the Wigner function and the spatial coordinates, such that the three blobs corresponding to the coherent states have different colors (matching the colors of the Julia logo).","category":"page"},{"location":"tutorials/logo/#Triangular-Cat-State","page":"Create QuantumToolbox.jl logo","title":"Triangular Cat State","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"A cat state, often referred to as a Schrödinger cat state, is a quantum state that is a superposition of two coherent states with opposite phases:","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":" psi_textcat rangle = frac1sqrt2 left(  alpha rangle +  -alpha rangle right)","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"where  alpha rangle is a coherent state with amplitude alpha.","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"The triangular cat state is a generalization of the standard cat state. It is a superposition of three coherent states with phases theta_0 theta_1 theta_2 separated by 120^circ(or 2pi3radians):","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":" psi_texttri-cat rangle = frac1sqrt3 left(  alpha_0 rangle +  alpha_1 rangle +  alpha_2 rangle right)","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"where alpha_j = rho e^itheta_jwith theta_j = fracpi2 + frac2pi j3and j = 0 1 2.","category":"page"},{"location":"tutorials/logo/#Wigner-Function","page":"Create QuantumToolbox.jl logo","title":"Wigner Function","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"The Wigner function W(x p)is a quasi-probability distribution used in quantum mechanics to represent quantum states in phase space. It is defined as:","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"W(x p) = frac1pi hbar int_-infty^infty psi^*(x + y) psi(x - y) e^2ipy  hbar  dy","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"where psi(x)is the wave function of the quantum state, xis the position, pis the momentum, and hbaris the reduced Planck constant. Unlike classical probability distributions, the Wigner function can take negative values, which indicates non-classical behavior.","category":"page"},{"location":"tutorials/logo/#Generating-the-Logo","page":"Create QuantumToolbox.jl logo","title":"Generating the Logo","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"First, let's load the required packages:","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"using QuantumToolbox\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\", pt_per_unit = 1)\nCairoMakie.enable_only_mime!(MIME\"image/svg+xml\"())","category":"page"},{"location":"tutorials/logo/#Parameters","page":"Create QuantumToolbox.jl logo","title":"Parameters","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"Here we define the parameters for the triangular cat state:","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"N = 30  # Cutoff of the Hilbert space for the harmonic oscillator\nρ = 2.5  # Amplitude of the coherent state\nθ1 = π / 2\nθ2 = π / 2 + 2π / 3\nθ3 = π / 2 + 4π / 3\nα1 = ρ * exp(im * θ1)\nα2 = ρ * exp(im * θ2)\nα3 = ρ * exp(im * θ3)","category":"page"},{"location":"tutorials/logo/#Constructing-the-State","page":"Create QuantumToolbox.jl logo","title":"Constructing the State","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"Next, we construct the triangular cat state as a normalized superposition of three coherent states:","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"ψ = coherent(N, α1) + coherent(N, α2) + coherent(N, α3)\nnormalize!(ψ)","category":"page"},{"location":"tutorials/logo/#Defining-the-Grid-and-calculating-the-Wigner-function","page":"Create QuantumToolbox.jl logo","title":"Defining the Grid and calculating the Wigner function","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"We define the grid for the Wigner function and calculate it using the wigner function. We shift the grid in the imaginary direction to ensure that the Wigner function is centered around the origin of the figure. The wigner function also supports the g scaling factor, which we put here equal to 2.","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"xvec = range(-ρ, ρ, 500) .* 1.5\nyvec = xvec .+ (abs(imag(α1)) - abs(imag(α2))) / 2\n\nwig = wigner(ψ, xvec, yvec, g = 2)","category":"page"},{"location":"tutorials/logo/#Plotting-the-Wigner-function","page":"Create QuantumToolbox.jl logo","title":"Plotting the Wigner function","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"Finally, we plot the Wigner function using the heatmap function from the CairoMakie package.","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"fig = Figure(size = (500, 500), figure_padding = 0)\nax = Axis(fig[1, 1])\nheatmap!(ax, xvec, yvec, wig', colormap = :RdBu, interpolate = true, rasterize = 1)\nhidespines!(ax)\nhidexdecorations!(ax)\nhideydecorations!(ax)\nfig","category":"page"},{"location":"tutorials/logo/#Introducing-some-decoherence","page":"Create QuantumToolbox.jl logo","title":"Introducing some decoherence","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"The figure obtained above coulb be already a potential logo for the package. However, we see that the fringe patterns are more intense than the three coherent gaussian amplitudes. We can introduce some decoherence to reduce this effect. Thus, we evolve the system under the evolution of a damped quantum harmonic oscillator, which is described by the Lindblad master equation:","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"fracd hatrhodt = -i hatH hatrho + gamma left( 2 hata hatrho hata^dagger - hata^dagger hata hatrho - hatrho hata^dagger hata right)","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"where hatrho is the density matrix, hatH = omega hata^dagger hatais the Hamiltonian of the harmonic oscillator (hbar = 1), hataand hata^daggerare the annihilation and creation operators, and gammais the damping rate. Thus, we initialize the system in the triangular cat state and evolve it under the Lindblad master equation, using the mesolve function.","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"γ = 0.012\n\na = destroy(N)\nH = a' * a\nc_ops = [sqrt(γ) * a]\n\ntlist = range(0, 2π, 100)\n\nsol = mesolve(H, ψ, tlist, c_ops, progress_bar = false)\nnothing # hide","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"And the Wigner function becomes more uniform:","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"wig = wigner(sol.states[end], xvec, yvec, g = 2)\n\nfig = Figure(size = (500, 500), figure_padding = 0)\nax = Axis(fig[1, 1])\n\nimg_wig = heatmap!(ax, xvec, yvec, wig', colormap = :RdBu, interpolate = true, rasterize = 1)\nhidespines!(ax)\nhidexdecorations!(ax)\nhideydecorations!(ax)\n\nfig","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"At this stage, we have finished to use the QuantumToolbox package. From now on, we will use the CairoMakie package to define custom colormaps and plot the Wigner function in a Julia logo style.","category":"page"},{"location":"tutorials/logo/#Custom-Colormap","page":"Create QuantumToolbox.jl logo","title":"Custom Colormap","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"We define a custom colormap that changes depending on the Wigner function and spatial coordinates. Indeed, we want the three different colormaps, in the regions corresponding to the three coherent states, to match the colors of the Julia logo. We also want the colormap change to be smooth, so we use a Gaussian function to blend the colors. We introduce also a Wigner function dependent transparency to make the logo more appealing.","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"function set_color_julia(x, y, wig::T, α1, α2, α3, cmap1, cmap2, cmap3, δ) where {T}\n    amp1 = gaussian(x, real(α1), δ) * gaussian(y, imag(α1), δ)\n    amp2 = gaussian(x, real(α2), δ) * gaussian(y, imag(α2), δ)\n    amp3 = gaussian(x, real(α3), δ) * gaussian(y, imag(α3), δ)\n\n    c1 = get(cmap1, wig)\n    c2 = get(cmap2, wig)\n    c3 = get(cmap3, wig)\n\n    c_tot = (amp1 * c1 + amp2 * c2 + amp3 * c3) / (amp1 + amp2 + amp3)\n\n    wig_abs = abs(2 * (wig - 1 / 2))\n    # We introduce some non-linearity to increase the contrast\n    alpha = 2 * (1 / (1 + exp(-5 * wig_abs)) - 1 / 2)\n\n    return RGBAf(c_tot.r, c_tot.g, c_tot.b, alpha)\nend\n\nX, Y = meshgrid(xvec, yvec)\nδ = 1.25 # Smoothing parameter for the Gaussian functions","category":"page"},{"location":"tutorials/logo/#Colormaps-from-the-Julia-colors","page":"Create QuantumToolbox.jl logo","title":"Colormaps from the Julia colors","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"We define the colormaps for the three coherent states using the colors of the Julia logo. We use the cgrad function from the CairoMakie package to create the colormaps.","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"julia_red = RGBAf(0.796, 0.235, 0.2, 1.0)\njulia_green = RGBAf(0.22, 0.596, 0.149, 1.0)\njulia_blue = RGBAf(0.251, 0.388, 0.847, 1.0)\njulia_purple = RGBAf(0.584, 0.345, 0.698, 1.0)\nn_repeats = 2\n\ncmap1 = cgrad(vcat(fill(julia_blue, n_repeats), fill(julia_green, n_repeats)))\ncmap2 = cgrad(vcat(fill(julia_blue, n_repeats), fill(julia_red, n_repeats)))\ncmap3 = cgrad(vcat(fill(julia_blue, n_repeats), fill(julia_purple, n_repeats)))","category":"page"},{"location":"tutorials/logo/#Normalizing-the-Wigner-function-and-applying-the-custom-colormap","page":"Create QuantumToolbox.jl logo","title":"Normalizing the Wigner function and applying the custom colormap","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"The colormaps require the input to be in the range 0 1. We normalize the Wigner function such that the maximum value is 1and the zeros are set to 05.","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"vmax = maximum(wig)\nwig_normalized = wig ./ (vmax * 2) .+ 1 / 2\nnothing # hide","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"And we now apply this custom colormap to make an image (a Matrix{RGBAf}).","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"img = set_color_julia.(X, Y, wig_normalized, α1, α2, α3, Ref(cmap1), Ref(cmap2), Ref(cmap3), δ)","category":"page"},{"location":"tutorials/logo/#Final-Plot","page":"Create QuantumToolbox.jl logo","title":"Final Plot","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"Finally, we plot the Wigner function with the custom colormap.","category":"page"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"fig = Figure(size = (500, 500), figure_padding = 0, backgroundcolor = :transparent)\nax = Axis(fig[1, 1], backgroundcolor = :transparent)\nimage!(ax, img', rasterize = 1)\nhidespines!(ax)\nhidexdecorations!(ax)\nhideydecorations!(ax)\nfig","category":"page"},{"location":"tutorials/logo/#Conclusion","page":"Create QuantumToolbox.jl logo","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/logo/","page":"Create QuantumToolbox.jl logo","title":"Create QuantumToolbox.jl logo","text":"This tutorial demonstrates how to generate the QuantumToolbox.jl logo using the package itself and Makie.jl for visualization. The logo is a visualization of the Wigner function of a triangular cat state, with a custom colormap that highlights the different coherent states with colors matching the Julia logo.","category":"page"},{"location":"users_guide/extensions/cuda/#doc:CUDA","page":"CUDA.jl","title":"CUDA.jl","text":"","category":"section"},{"location":"users_guide/extensions/cuda/","page":"CUDA.jl","title":"CUDA.jl","text":"This page is still under construction, please visit API first.","category":"page"},{"location":"qutip_differences/","page":"Key differences from QuTiP","title":"Key differences from QuTiP","text":"CurrentModule = QuantumToolbox","category":"page"},{"location":"qutip_differences/#doc:Key-differences-from-QuTiP","page":"Key differences from QuTiP","title":"Key differences from QuTiP","text":"","category":"section"},{"location":"qutip_differences/","page":"Key differences from QuTiP","title":"Key differences from QuTiP","text":"This page is still under construction, please visit API first.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = QuantumToolbox","category":"page"},{"location":"#QuantumToolbox.jl-Documentation","page":"Introduction","title":"QuantumToolbox.jl Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumToolbox.jl is a cutting-edge Julia package designed for quantum physics simulations, closely emulating the popular Python QuTiP package. It uniquely combines the simplicity and power of Julia with advanced features like GPU acceleration and distributed computing, making simulation of quantum systems more accessible and efficient.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"With this package, moving from Python to Julia for quantum physics simulations has never been easier, due to the similar syntax and functionalities.","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumToolbox.jl is equipped with a robust set of features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Quantum State and Operator Manipulation: Easily handle quantum states and operators with a rich set of tools, with the same functionalities as QuTiP.\nDynamical Evolution: Advanced solvers for time evolution of quantum systems, thanks to the powerful DifferentialEquations.jl package.\nGPU Computing: Leverage GPU resources for high-performance computing. For example, you run the master equation direclty on the GPU with the same syntax as the CPU case.\nDistributed Computing: Distribute the computation over multiple nodes (e.g., a cluster). For example, you can run undreds of quantum trajectories in parallel on a cluster, with, again, the same syntax as the simple case.\nEasy Extension: Easily extend the package, taking advantage of the Julia language features, like multiple dispatch and metaprogramming.","category":"page"},{"location":"#doc:Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Requirements\nQuantumToolbox.jl requires Julia 1.7+.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To install QuantumToolbox.jl, run the following commands inside Julia's interactive session (also known as REPL):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"QuantumToolbox\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Alternatively, this can also be done in Julia's Pkg REPL by pressing the key ] in the REPL to use the package mode, and then type the following command:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(1.7) pkg> add QuantumToolbox","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"More information about Julia's package manager can be found at Pkg.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To load the package and check the version information, use either QuantumToolbox.versioninfo() or QuantumToolbox.about(), namely","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using QuantumToolbox\nQuantumToolbox.versioninfo()\nQuantumToolbox.about()","category":"page"},{"location":"#Brief-Example","page":"Introduction","title":"Brief Example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We now provide a brief example to demonstrate the similarity between QuantumToolbox.jl and QuTiP.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Let's consider a quantum harmonic oscillator with a Hamiltonian given by:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"hatH = omega hata^dagger hata","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where hata and hata^dagger are the annihilation and creation operators, respectively. We can define the Hamiltonian as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using QuantumToolbox\n\nN = 20 # cutoff of the Hilbert space dimension\nω = 1.0 # frequency of the harmonic oscillator\n\na = destroy(N) # annohilation operator\n\nH = ω * a' * a","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We now introduce some losses in a thermal environment, described by the Lindblad master equation:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"fracd hatrhodt = -i hatH hatrho + gamma mathcalDhata hatrho","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where hatrho is the density matrix, gamma is the damping rate, and mathcalDhata is the Lindblad dissipator, defined as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"mathcalDhatahatrho = hatahatrhohata^dagger - frac12hata^daggerhatahatrho - frac12hatrhohata^daggerhata","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We now compute the time evolution of the system using the mesolve function, starting from the initial state ketpsi (0) = ket3:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"γ = 0.1 # damping rate\n\nψ0 = fock(N, 3) # initial state\n\ntlist = range(0, 10, 100) # time list\n\nc_ops = [sqrt(γ) * a]\ne_ops = [a' * a]\n\nsol = mesolve(H, ψ0, tlist, c_ops, e_ops = e_ops)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We can extract the expectation value of the number operator hata^dagger hata with the command sol.expect, and the states with the command sol.states.","category":"page"},{"location":"#Support-for-GPU-calculation","page":"Introduction","title":"Support for GPU calculation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We can easily pass the computation to the GPU, by simply passing all the Qobjs to the GPU:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"compat: Compat\nThe described feature requires Julia 1.9+. See CUDA extension for more details.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using QuantumToolbox\nusing CUDA\n\na_gpu = cu(destroy(N)) # The only difference in the code is the cu() function\n\nH_gpu = ω * a_gpu' * a_gpu\n\nψ0_gpu = cu(fock(N, 3))\n\nc_ops = [sqrt(γ) * a_gpu]\ne_ops = [a_gpu' * a_gpu]\n\nsol = mesolve(H_gpu, ψ0_gpu, tlist, c_ops, e_ops = e_ops)","category":"page"},{"location":"tutorials/lowrank/#doc-tutor:Low-rank-master-equation","page":"Low Rank Master Equation","title":"Low rank master equation","text":"","category":"section"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"We start by importing the packages","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"using QuantumToolbox\nusing CairoMakie\nCairoMakie.enable_only_mime!(MIME\"image/svg+xml\"())","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define lattice","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Nx, Ny = 2, 3\nlatt = Lattice(Nx = Nx, Ny = Ny)","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define lr-space dimensions","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"N_cut = 2         # Number of states of each mode\nN_modes = latt.N  # Number of modes\nN = N_cut^N_modes # Total number of states\nM = Nx * Ny + 1       # Number of states in the LR basis","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define lr states. Take as initial state all spins up. All other N states are taken as those with miniman Hamming distance to the initial state.","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"ϕ = Vector{QuantumObject{Vector{ComplexF64},KetQuantumObject}}(undef, M)\nϕ[1] = kron(repeat([basis(2, 0)], N_modes)...)\n\nglobal i = 1\nfor j in 1:N_modes\n    global i += 1\n    i <= M && (ϕ[i] = mb(sp, j, latt) * ϕ[1])\nend\nfor k in 1:N_modes-1\n    for l in k+1:N_modes\n        global i += 1\n        i <= M && (ϕ[i] = mb(sp, k, latt) * mb(sp, l, latt) * ϕ[1])\n    end\nend\nfor i in i+1:M\n    ϕ[i] = QuantumObject(rand(ComplexF64, size(ϕ[1])[1]), dims = ϕ[1].dims)\n    normalize!(ϕ[i])\nend","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define the initial state","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"z = hcat(broadcast(x -> x.data, ϕ)...)\np0 = 0.0 # Population of the lr states other than the initial state\nB = Matrix(Diagonal([1 + 0im; p0 * ones(M - 1)]))\nS = z' * z # Overlap matrix\nB = B / tr(S * B) # Normalize B\n\nρ = QuantumObject(z * B * z', dims = ones(Int, N_modes) * N_cut); # Full density matrix","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define the Hamiltonian and collapse operators","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"# Define Hamiltonian and collapse operators\nJx = 0.9\nJy = 1.04\nJz = 1.0\nhx = 0.0\nγ = 1\n\nSx = sum([mb(sx, i, latt) for i in 1:latt.N])\nSy = sum([mb(sy, i, latt) for i in 1:latt.N])\nSz = sum([mb(sz, i, latt) for i in 1:latt.N])\nSFxx = sum([mb(sx, i, latt) * mb(sx, j, latt) for i in 1:latt.N for j in 1:latt.N])\n\nH, c_ops = TFIM(Jx, Jy, Jz, hx, γ, latt; bc = pbc, order = 1)\ne_ops = (Sx, Sy, Sz, SFxx)\n\ntl = LinRange(0, 10, 100);","category":"page"},{"location":"tutorials/lowrank/#Full-evolution","page":"Low Rank Master Equation","title":"Full evolution","text":"","category":"section"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"@time mesol = mesolve(H, ρ, tl, c_ops; e_ops = [e_ops...]);\nA = Matrix(mesol.states[end].data)\nλ = eigvals(Hermitian(A))\nStrue = -sum(λ .* log2.(λ)) / latt.N;","category":"page"},{"location":"tutorials/lowrank/#Low-Rank-evolution","page":"Low Rank Master Equation","title":"Low Rank evolution","text":"","category":"section"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define functions to be evaluated during the low-rank evolution","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"function f_purity(p, z, B)\n    N = p.N\n    M = p.M\n    S = p.S\n    T = p.temp_MM\n\n    mul!(T, S, B)\n    return tr(T^2)\nend\n\nfunction f_trace(p, z, B)\n    N = p.N\n    M = p.M\n    S = p.S\n    T = p.temp_MM\n\n    mul!(T, S, B)\n    return tr(T)\nend\n\nfunction f_entropy(p, z, B)\n    C = p.A0\n    σ = p.Bi\n\n    mul!(C, z, sqrt(B))\n    mul!(σ, C', C)\n    λ = eigvals(Hermitian(σ))\n    λ = λ[λ.>1e-10]\n    return -sum(λ .* log2.(λ))\nend;","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Define the options for the low-rank evolution","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"opt =\n    LRMesolveOptions(alg = Tsit5(), err_max = 1e-3, p0 = 0.0, atol_inv = 1e-6, adj_condition = \"variational\", Δt = 0.0);\n\n@time lrsol = lr_mesolve(H, z, B, tl, c_ops; e_ops = e_ops, f_ops = (f_purity, f_entropy, f_trace), opt = opt);","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"Plot the results","category":"page"},{"location":"tutorials/lowrank/","page":"Low Rank Master Equation","title":"Low Rank Master Equation","text":"m_me = real(mesol.expect[3, :]) / Nx / Ny\nm_lr = real(lrsol.expvals[3, :]) / Nx / Ny\n\nfig = Figure(size = (800, 400), fontsize = 15)\nax = Axis(fig[1, 1], xlabel = L\"\\gamma t\", ylabel = L\"M_{z}\", xlabelsize = 20, ylabelsize = 20)\nlines!(ax, tl, m_lr, label = L\"LR $[M=M(t)]$\", linewidth = 2)\nlines!(ax, tl, m_me, label = \"Fock\", linewidth = 2, linestyle = :dash)\naxislegend(ax, position = :rb)\n\nax2 = Axis(fig[1, 2], xlabel = L\"\\gamma t\", ylabel = \"Value\", xlabelsize = 20, ylabelsize = 20)\nlines!(ax2, tl, 1 .- real(lrsol.funvals[1, :]), label = L\"$1-P$\", linewidth = 2)\nlines!(\n    ax2,\n    tl,\n    1 .- real(lrsol.funvals[3, :]),\n    label = L\"$1-\\mathrm{Tr}(\\rho)$\",\n    linewidth = 2,\n    linestyle = :dash,\n    color = :orange,\n)\nlines!(ax2, tl, real(lrsol.funvals[2, :]) / Nx / Ny, color = :blue, label = L\"S\", linewidth = 2)\nhlines!(ax2, [Strue], color = :blue, linestyle = :dash, linewidth = 2, label = L\"S^{\\,\\mathrm{true}}_{\\mathrm{ss}}\")\naxislegend(ax2, position = :rb)\n\nfig","category":"page"}]
}
