<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving for Steady-State Solutions · QuantumToolbox.jl</title><meta name="title" content="Solving for Steady-State Solutions · QuantumToolbox.jl"/><meta property="og:title" content="Solving for Steady-State Solutions · QuantumToolbox.jl"/><meta property="twitter:title" content="Solving for Steady-State Solutions · QuantumToolbox.jl"/><meta name="description" content="Documentation for QuantumToolbox.jl."/><meta property="og:description" content="Documentation for QuantumToolbox.jl."/><meta property="twitter:description" content="Documentation for QuantumToolbox.jl."/><meta property="og:url" content="https://qutip.github.io/QuantumToolbox.jl/users_guide/steadystate/"/><meta property="twitter:url" content="https://qutip.github.io/QuantumToolbox.jl/users_guide/steadystate/"/><link rel="canonical" href="https://qutip.github.io/QuantumToolbox.jl/users_guide/steadystate/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="QuantumToolbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../qutip_differences/">Key differences from QuTiP</a></li><li><a class="tocitem" href="../../type_stability/">The Importance of Type-Stability</a></li></ul></li><li><span class="tocitem">Users Guide</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Basic Operations on Quantum Objects</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../QuantumObject/QuantumObject/">Quantum Objects (Qobj)</a></li><li><a class="tocitem" href="../QuantumObject/QuantumObject_functions/">Functions operating on Qobj</a></li></ul></li><li><a class="tocitem" href="../states_and_operators/">Manipulating States and Operators</a></li><li><a class="tocitem" href="../tensor/">Tensor Products and Partial Traces</a></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Time Evolution and Dynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../time_evolution/intro/">Introduction</a></li><li><a class="tocitem" href="../time_evolution/solution/">Time Evolution Solutions</a></li><li><a class="tocitem" href="../time_evolution/sesolve/">Schrödinger Equation Solver</a></li><li><a class="tocitem" href="../time_evolution/mesolve/">Lindblad Master Equation Solver</a></li><li><a class="tocitem" href="../time_evolution/mcsolve/">Monte-Carlo Solver</a></li><li><a class="tocitem" href="../time_evolution/stochastic/">Stochastic Solver</a></li><li><a class="tocitem" href="../time_evolution/time_dependent/">Solving Problems with Time-dependent Hamiltonians</a></li></ul></li><li class="is-active"><a class="tocitem" href>Solving for Steady-State Solutions</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Steady-State-solvers-in-QuantumToolbox.jl"><span>Steady State solvers in <code>QuantumToolbox.jl</code></span></a></li><li><a class="tocitem" href="#Using-Steady-State-solvers"><span>Using Steady State solvers</span></a></li><li><a class="tocitem" href="#Example:-Harmonic-oscillator-in-thermal-bath"><span>Example: Harmonic oscillator in thermal bath</span></a></li><li><a class="tocitem" href="#Calculate-steady-state-for-periodically-driven-systems"><span>Calculate steady state for periodically driven systems</span></a></li></ul></li><li><span class="tocitem">Symmetries</span></li><li><span class="tocitem">Two-time correlation functions</span></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Extensions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../extensions/cuda/">Extension for CUDA.jl</a></li></ul></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Time Evolution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/lowrank/">Low Rank Master Equation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Miscellaneous Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/logo/">Create QuantumToolbox.jl logo</a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Users Guide</a></li><li class="is-active"><a href>Solving for Steady-State Solutions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solving for Steady-State Solutions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/qutip/QuantumToolbox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/qutip/QuantumToolbox.jl/blob/main/docs/src/users_guide/steadystate.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="doc:Solving-for-Steady-State-Solutions"><a class="docs-heading-anchor" href="#doc:Solving-for-Steady-State-Solutions">Solving for Steady-State Solutions</a><a id="doc:Solving-for-Steady-State-Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#doc:Solving-for-Steady-State-Solutions" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as <span>$t\rightarrow\infty$</span> that satisfies the equation</p><p class="math-container">\[\frac{d\hat{\rho}_{\textrm{ss}}}{dt} = \mathcal{L}\hat{\rho}_{\textrm{ss}}=0.\]</p><p>Although the requirement for time-independence seems quite restrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix <span>$\hat{\rho}_{\textrm{ss}}$</span> can be achieved using direct or iterative solution methods faster than using master equation or Monte-Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find.</p><h2 id="Steady-State-solvers-in-QuantumToolbox.jl"><a class="docs-heading-anchor" href="#Steady-State-solvers-in-QuantumToolbox.jl">Steady State solvers in <code>QuantumToolbox.jl</code></a><a id="Steady-State-solvers-in-QuantumToolbox.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-State-solvers-in-QuantumToolbox.jl" title="Permalink"></a></h2><p>In <code>QuantumToolbox.jl</code>, the steady-state solution for a system Hamiltonian or Liouvillian is given by <a href="../../api/#QuantumToolbox.steadystate"><code>steadystate</code></a>. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the <code>solver</code> keyword argument.</p><table><tr><th style="text-align: left"><strong>Solver</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><a href="../../api/#QuantumToolbox.SteadyStateDirectSolver"><code>SteadyStateDirectSolver()</code></a></td><td style="text-align: left">Directly solve <span>$Ax=b$</span> using the standard method given in <code>Julia</code> <code>LinearAlgebra</code></td></tr><tr><td style="text-align: left"><a href="../../api/#QuantumToolbox.SteadyStateLinearSolver"><code>SteadyStateLinearSolver()</code></a></td><td style="text-align: left">Directly solve <span>$Ax=b$</span> using the algorithms given in <a href="https://docs.sciml.ai/LinearSolve/stable/"><code>LinearSolve.jl</code></a></td></tr><tr><td style="text-align: left"><a href="../../api/#QuantumToolbox.SteadyStateEigenSolver"><code>SteadyStateEigenSolver()</code></a></td><td style="text-align: left">Find the zero (or lowest) eigenvalue of <span>$\mathcal{L}$</span> using <a href="../../api/#QuantumToolbox.eigsolve"><code>eigsolve</code></a></td></tr><tr><td style="text-align: left"><a href="../../api/#QuantumToolbox.SteadyStateODESolver"><code>SteadyStateODESolver()</code></a></td><td style="text-align: left">Solving time evolution with algorithms given in <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/"><code>DifferentialEquations.jl</code> (ODE Solvers)</a></td></tr></table><h2 id="Using-Steady-State-solvers"><a class="docs-heading-anchor" href="#Using-Steady-State-solvers">Using Steady State solvers</a><a id="Using-Steady-State-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Steady-State-solvers" title="Permalink"></a></h2><p>The function <a href="../../api/#QuantumToolbox.steadystate"><code>steadystate</code></a> can take either a Hamiltonian and a list of collapse operators <code>c_ops</code> as input, generating internally the corresponding Liouvillian <span>$\mathcal{L}$</span> in Lindblad form, or alternatively, a Liouvillian <span>$\mathcal{L}$</span> passed by the user.</p><pre><code class="language-julia hljs">ρ_ss = steadystate(H)        # Hamiltonian
ρ_ss = steadystate(H, c_ops) # Hamiltonian and collapse operators
ρ_ss = steadystate(L)        # Liouvillian</code></pre><p>where <code>H</code> is a quantum object representing the system Hamiltonian (<a href="../../api/#QuantumToolbox.Operator"><code>Operator</code></a>) or Liouvillian (<a href="../../api/#QuantumToolbox.SuperOperator"><code>SuperOperator</code></a>), and <code>c_ops</code> (defaults to <code>nothing</code>) can be a list of <a href="../../api/#QuantumToolbox.QuantumObject"><code>QuantumObject</code></a> for the system collapse operators. The output, labelled as <code>ρ_ss</code>, is the steady-state solution for the systems. If no other keywords are passed to the function, the default solver <a href="../../api/#QuantumToolbox.SteadyStateDirectSolver"><code>SteadyStateDirectSolver()</code></a> is used.</p><p>To change a solver, use the keyword argument <code>solver</code>, for example:</p><pre><code class="language-julia hljs">ρ_ss = steadystate(H, c_ops; solver = SteadyStateLinearSolver())</code></pre><div class="admonition is-info"><header class="admonition-header">Initial state for `SteadyStateODESolver()`</header><div class="admonition-body"><p>It is necessary to provide the initial state <code>ψ0</code> for ODE solving method, namely <code>steadystate(H, ψ0, tspan, c_ops, solver = SteadyStateODESolver())</code>, where <code>tspan::Real</code> represents the final time step, defaults to <code>Inf</code> (infinity).</p></div></div><p>Although it is not obvious, the <a href="../../api/#QuantumToolbox.SteadyStateDirectSolver"><code>SteadyStateDirectSolver()</code></a> and <a href="../../api/#QuantumToolbox.SteadyStateEigenSolver"><code>SteadyStateEigenSolver()</code></a> methods all use an LU decomposition internally and thus can have a large memory overhead. In contrast, for <a href="../../api/#QuantumToolbox.SteadyStateLinearSolver"><code>SteadyStateLinearSolver()</code></a>, iterative algorithms provided by <a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/"><code>LinearSolve.jl</code></a>, such as <code>KrylovJL_GMRES()</code> and <code>KrylovJL_BICGSTAB()</code>, do not factor the matrix and thus take less memory than the LU methods and allow, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. </p><p>To overcome this, one can provide preconditioner that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The left and right preconditioner can be specified as the keyword argument <code>Pl</code> and <code>Pr</code>, respectively:</p><pre><code class="language-julia hljs">solver = SteadyStateLinearSolver(alg = KrylovJL_GMRES(), Pl = Pl, Pr = Pr)</code></pre><p>The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. Moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. </p><p>Furthermore, <code>QuantiumToolbox</code> can take advantage of the Intel (Pardiso) LU solver in the Intel Math Kernel library (Intel-MKL) by using <a href="https://docs.sciml.ai/LinearSolve/stable/"><code>LinearSolve.jl</code></a> and either <a href="https://github.com/JuliaSparse/Pardiso.jl"><code>Pardiso.jl</code></a> or <a href="https://github.com/JuliaBinaryWrappers/MKL_jll.jl"><code>MKL_jll.jl</code></a>:</p><pre><code class="language-julia hljs">using QuantumToolbox
using LinearSolve # must be loaded

using Pardiso
solver = SteadyStateLinearSolver(alg = MKLPardisoFactorize())

using MKL_jll
solver = SteadyStateLinearSolver(alg = MKLLUFactorization())</code></pre><p>See <a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/"><code>LinearSolve.jl</code> Solvers</a> for more details.</p><h2 id="Example:-Harmonic-oscillator-in-thermal-bath"><a class="docs-heading-anchor" href="#Example:-Harmonic-oscillator-in-thermal-bath">Example: Harmonic oscillator in thermal bath</a><a id="Example:-Harmonic-oscillator-in-thermal-bath-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Harmonic-oscillator-in-thermal-bath" title="Permalink"></a></h2><p>Here, we demonstrate <a href="../../api/#QuantumToolbox.steadystate"><code>steadystate</code></a> by using the example with the harmonic oscillator in thermal bath from the previous section (<a href="../time_evolution/mesolve/#doc-TE:Lindblad-Master-Equation-Solver">Lindblad Master Equation Solver</a>).</p><pre><code class="language-julia hljs">using QuantumToolbox
using CairoMakie
CairoMakie.enable_only_mime!(MIME&quot;image/svg+xml&quot;())

# Define parameters
N = 20  # number of basis states to consider
a = destroy(N)
H = a&#39; * a
ψ0 = basis(N, 10)  # initial state
κ = 0.1  # coupling to oscillator
n_th = 2 # temperature with average of 2 excitations

# collapse operators
c_ops = [
    sqrt(κ * (n_th + 1)) * a, # emission
    sqrt(κ *  n_th     ) * a&#39; # absorption
]

# find steady-state solution
ρ_ss = steadystate(H, c_ops)

# find expectation value for particle number in steady state
e_ops = [a&#39; * a]
exp_ss = real(expect(e_ops[1], ρ_ss))

tlist = LinRange(0, 50, 100)

# monte-carlo
sol_mc = mcsolve(H, ψ0, tlist, c_ops, e_ops=e_ops, ntraj=100, progress_bar=false)
exp_mc = real(sol_mc.expect[1, :])

# master eq.
sol_me = mesolve(H, ψ0, tlist, c_ops, e_ops=e_ops, progress_bar=false)
exp_me = real(sol_me.expect[1, :])

# plot the results
fig = Figure(size = (500, 350))
ax = Axis(fig[1, 1],
    title = L&quot;Decay of Fock state $|10\rangle$ in a thermal environment with $\langle n\rangle=2$&quot;,
    xlabel = &quot;Time&quot;,
    ylabel = &quot;Number of excitations&quot;,
)
lines!(ax, tlist, exp_mc, label = &quot;Monte-Carlo&quot;, linewidth = 2, color = :blue)
lines!(ax, tlist, exp_me, label = &quot;Master Equation&quot;, linewidth = 2, color = :orange, linestyle = :dash)
lines!(ax, tlist, exp_ss .* ones(length(tlist)), label = &quot;Steady State&quot;, linewidth = 2, color = :red)
axislegend(ax, position = :rt)

fig</code></pre><img src="f80771f1.svg" alt="Example block output"/><h2 id="Calculate-steady-state-for-periodically-driven-systems"><a class="docs-heading-anchor" href="#Calculate-steady-state-for-periodically-driven-systems">Calculate steady state for periodically driven systems</a><a id="Calculate-steady-state-for-periodically-driven-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Calculate-steady-state-for-periodically-driven-systems" title="Permalink"></a></h2><p>See the docstring of <a href="../../api/#QuantumToolbox.steadystate_floquet"><code>steadystate_floquet</code></a> for more details.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../time_evolution/time_dependent/">« Solving Problems with Time-dependent Hamiltonians</a><a class="docs-footer-nextpage" href="../extensions/cuda/">Extension for CUDA.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 29 October 2024 01:19">Tuesday 29 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
